{"ast":null,"code":"'use strict';\n\nconst _require = require('buffer'),\n      Buffer = _require.Buffer;\n\nconst configure = require('../lib/configure');\n\nconst _require2 = require('../lib/querystring'),\n      objectToQuery = _require2.objectToQuery;\n\nconst _require3 = require('../lib/fetch'),\n      ok = _require3.ok;\n\nmodule.exports = configure(({\n  fetch,\n  apiUrl,\n  apiPath,\n  headers\n}) => {\n  return async (topic, data, options) => {\n    options = options || {};\n    let qs = objectToQuery(options.qs);\n    qs = qs ? \"&\".concat(qs.slice(1)) : qs;\n    const url = \"\".concat(apiUrl).concat(apiPath, \"/pubsub/pub?arg=\").concat(encodeURIComponent(topic), \"&arg=\").concat(encodeBuffer(Buffer.from(data))).concat(qs);\n    const res = await ok(fetch(url, {\n      method: 'POST',\n      signal: options.signal,\n      headers: options.headers || headers\n    }));\n    return res.text();\n  };\n});\n\nfunction encodeBuffer(buf) {\n  let uriEncoded = '';\n\n  for (const byte of buf) {\n    // https://tools.ietf.org/html/rfc3986#page-14\n    // ALPHA (%41-%5A and %61-%7A), DIGIT (%30-%39), hyphen (%2D), period (%2E),\n    // underscore (%5F), or tilde (%7E)\n    if (byte >= 0x41 && byte <= 0x5A || byte >= 0x61 && byte <= 0x7A || byte >= 0x30 && byte <= 0x39 || byte === 0x2D || byte === 0x2E || byte === 0x5F || byte === 0x7E) {\n      uriEncoded += String.fromCharCode(byte);\n    } else {\n      uriEncoded += \"%\".concat(byte.toString(16).padStart(2, '0'));\n    }\n  }\n\n  return uriEncoded;\n}","map":null,"metadata":{},"sourceType":"script"}