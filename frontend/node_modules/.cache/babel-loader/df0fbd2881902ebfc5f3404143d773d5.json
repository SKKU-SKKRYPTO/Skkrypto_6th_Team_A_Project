{"ast":null,"code":"/*\n    Copyright 2021 The caver-js Authors\n    This file is part of the caver-js library.\n\n    The caver-js library is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    The caver-js library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with the caver-js. If not, see <http://www.gnu.org/licenses/>.\n*/\nconst utils = require('../../caver-utils');\n\nconst _require = require('../../caver-wallet/src/keyring/keyringHelper'),\n      KEY_ROLE = _require.KEY_ROLE;\n\nconst _require2 = require('../../caver-transaction/src/transactionHelper/transactionHelper'),\n      refineSignatures = _require2.refineSignatures;\n\nconst AbstractTransaction = require('../../caver-transaction/src/transactionTypes/abstractTransaction');\n\nconst AbstractFeeDelegatedTransaction = require('../../caver-transaction/src/transactionTypes/abstractFeeDelegatedTransaction');\n/**\n * Representing a class to support validation functions.\n * @class\n * @hideconstructor\n */\n\n\nclass Validator {\n  /**\n   * Validates a signed message by comparing the public key recovered from the signature with the account key of the Klaytn account.\n   *\n   * @example\n   * const address = '0x...'\n   * const message = 'Some data'\n   * const signature = { v: '0x1c', r: '0xd0b8d...', s: '0x5472e...' } // You can get a signature via `keyring.signMessage(...).signatures[0]`.\n   * const isValid = caver.validator.validateSignedMessage(message, signature, address)\n   *\n   * @memberof Validator\n   * @inner\n   *\n   * @param {string} message The raw message string. If this message is hased with Klaytn specific prefix, the third parameter should be passed as `true`.\n   * @param {SignatureData|Array.<SignatureData>} signatures An instance of `SignatureData` or an array of `SignatureData`.\n   * @param {string} address The address of the account that signed the message.\n   * @param {boolean} [isHashed] (optional, default: `false`) If the `isHashed` is true, the given message will NOT automatically be prefixed with \"\\x19Klaytn Signed Message:\\n\" + message.length + message, and be assumed as already prefixed.\n   * @return {Promise<boolean>} The promise will be resolved with a boolean value of whether the signature on the message is valid or not.\n   */\n  async validateSignedMessage(message, signatures, address, isHashed = false) {\n    const getAccountKeyResult = await Validator._klaytnCall.getAccountKey(address); // Remove duplicate and format to `Array.<SignatureData>` type.\n\n    signatures = refineSignatures(signatures);\n    const publicKeys = [];\n\n    for (const sig of signatures) {\n      const recovered = utils.recoverPublicKey(message, sig, isHashed);\n      const pub = recovered.toString();\n      publicKeys.push(pub);\n    }\n\n    return validateWithAccountKeyAndRole(address, getAccountKeyResult, publicKeys, KEY_ROLE.roleTransactionKey);\n  }\n  /**\n   * Validates a transaction.\n   * This function compares the public keys from the account key of the Klaytn account with the public keys recovered from `signatures`.\n   * If the transaction is fee-delegated with the `feePayerSignatures` variable inside, this function compares the public keys recovered from `feePayerSignatures` with the public keys of the fee payer.\n   *\n   * @example\n   * const tx = caver.transaction.valueTransfer.create({...})\n   * const isValid = caver.validator.validateTransaction(tx)\n   *\n   * @memberof Validator\n   * @inner\n   *\n   * @param {module:Transaction.Transaction} tx An instance of transaction to validate.\n   * @return {boolean}\n   */\n\n\n  async validateTransaction(tx) {\n    let isValid = await this.validateSender(tx);\n\n    if (isValid === true && tx instanceof AbstractFeeDelegatedTransaction) {\n      isValid = this.validateFeePayer(tx);\n    }\n\n    return isValid;\n  }\n  /**\n   * Validates the sender of the transaction.\n   * This function compares the public keys of the account key of the Klaytn account with the public keys recovered from `signatures`.\n   *\n   * @example\n   * const tx = caver.transaction.valueTransfer.create({...})\n   * const isValid = caver.validator.validateSender(tx)\n   *\n   * @memberof Validator\n   * @inner\n   *\n   * @param {module:Transaction.Transaction} tx An instance of transaction to validate.\n   * @return {boolean}\n   */\n\n\n  async validateSender(tx) {\n    if (!(tx instanceof AbstractTransaction)) throw new Error('Invalid parameter type: To validate `signatures` field in the transaction, you need to pass the transaction instance.');\n    const fromAccountKey = await Validator._klaytnCall.getAccountKey(tx.from);\n    const publicKeys = tx.recoverPublicKeys();\n    const role = tx.type.includes('AccountUpdate') ? KEY_ROLE.roleAccountUpdateKey : KEY_ROLE.roleTransactionKey;\n    return validateWithAccountKeyAndRole(tx.from, fromAccountKey, publicKeys, role);\n  }\n  /**\n   * Validates a fee payer in the transaction.\n   * This function compares the public keys of the account key of the fee payer with the public keys recovered from `feePayerSignatures`.\n   *\n   * @example\n   * const tx = caver.transaction.feeDelegatedValueTransfer.create({...})\n   * const isValid = caver.validator.validateFeePayer(tx)\n   *\n   * @memberof Validator\n   * @inner\n   *\n   * @param {module:Transaction.FeeDelegatedTransaction} tx An instance of transaction to validate.\n   * @return {boolean}\n   */\n\n\n  async validateFeePayer(tx) {\n    if (!(tx instanceof AbstractFeeDelegatedTransaction)) throw new Error('Invalid parameter type: To validate `feePayerSignatures` field in the transaction, you need to pass the fee-delegated transaction instance.');\n    const feePayerAccountKey = await Validator._klaytnCall.getAccountKey(tx.feePayer);\n    const publicKeys = tx.recoverFeePayerPublicKeys();\n    const role = KEY_ROLE.roleFeePayerKey;\n    return validateWithAccountKeyAndRole(tx.feePayer, feePayerAccountKey, publicKeys, role);\n  }\n\n}\n\nfunction validateWithAccountKeyAndRole(address, accountKey, publicKeys, role) {\n  let isValid = false; // For accounts that have not yet been applied in Klaytn's state, the return value of `caver.rpc.klay.getAccountKey` is null.\n  // In this case, the account's key has never been updated, so the logic is the same as in AccountKeyLegacy.\n\n  if (accountKey === null) accountKey = {\n    keyType: 1,\n    key: {}\n  };\n\n  switch (accountKey.keyType) {\n    case 1:\n      // TODO: If an invalid signature is included, it should be changed to return false.\n      // if (signatures.length > 1) return isValid\n      for (const pub of publicKeys) {\n        const recoveredAddress = utils.publicKeyToAddress(pub);\n\n        if (recoveredAddress.toLowerCase() === address.toLowerCase()) {\n          isValid = true;\n          break;\n        }\n      }\n\n      break;\n\n    case 2:\n      // TODO: If an invalid signature is included, it should be changed to return false.\n      // if (signatures.length > 1) return isValid\n      for (const pub of publicKeys) {\n        const xyPoints = utils.xyPointFromPublicKey(pub);\n\n        if (xyPoints[0].toLowerCase() === accountKey.key.x.toLowerCase() && xyPoints[1].toLowerCase() === accountKey.key.y.toLowerCase()) {\n          isValid = true;\n          break;\n        }\n      }\n\n      break;\n\n    case 3:\n      break;\n\n    case 4:\n      // TODO: If an invalid signature is included, it should be changed to return false.\n      // if (signatures.length > accountKey.key.keys.length) return isValid\n      let weightSum = 0;\n      const threshold = accountKey.key.threshold;\n\n      for (const pub of publicKeys) {\n        for (const pubKey of accountKey.key.keys) {\n          const xyPoints = utils.xyPointFromPublicKey(pub);\n\n          if (xyPoints[0].toLowerCase() === pubKey.key.x.toLowerCase() && xyPoints[1].toLowerCase() === pubKey.key.y.toLowerCase()) {\n            weightSum += pubKey.weight;\n            break;\n          }\n        } // If sum of weight is satisfied threshold, signatures are valid.\n\n\n        if (weightSum >= threshold) {\n          isValid = true;\n          break;\n        }\n      }\n\n      break;\n\n    case 5:\n      // If the AccountKey of the account is AccountKeyRoleBased,\n      // it is judged as valid only if the signature is signed using valid role key.\n      const roleKey = accountKey.key[role];\n      if (accountKey.key[role].keyType === 5) throw new Error(\"Invalid account key type: nested composite type\");\n      isValid = validateWithAccountKeyAndRole(address, roleKey, publicKeys);\n      break;\n\n    default:\n      throw new Error(\"Invalid account key type\");\n  }\n\n  return isValid;\n}\n\nmodule.exports = Validator;","map":null,"metadata":{},"sourceType":"script"}