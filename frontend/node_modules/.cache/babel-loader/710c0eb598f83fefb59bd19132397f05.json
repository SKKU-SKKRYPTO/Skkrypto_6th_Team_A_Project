{"ast":null,"code":"/*\n    Modifications copyright 2018 The caver-js Authors\n    This file is part of web3.js.\n\n    web3.js is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    web3.js is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n\n    This file is derived from web3.js/packages/web3-eth-abi/src/index.js (2019/06/12).\n    Modified and improved for the caver-js development.\n*/\n\n/**\n * @file index.js\n * @author Marek Kotewicz <marek@parity.io>\n * @author Fabian Vogelsteller <fabian@frozeman.de>\n * @date 2017\n */\nconst _ = require('lodash');\n\nconst EthersAbiCoder = require('@ethersproject/abi').AbiCoder;\n\nconst ParamType = require('@ethersproject/abi').ParamType;\n\nconst utils = require('../../caver-utils');\n\nconst ethersAbiCoder = new EthersAbiCoder(function (type, value) {\n  if (type.match(/^u?int/) && !_.isArray(value) && (!_.isObject(value) || value.constructor.name !== 'BN')) {\n    return value.toString();\n  }\n\n  return value;\n}); // result method\n\nfunction Result() {}\n\nclass ABI {\n  /**\n   * Encodes the function signature to its ABI signature, which are the first 4 bytes of the sha3 hash of the function name including parameter types.\n   *\n   * @example\n   * caver.abi.encodeFunctionSignature({ name: 'myMethod', type: 'function', inputs: [{ type: 'uint256', name: 'myNumber' },{ type: 'string', name: 'mystring' }]})\n   *\n   * caver.abi.encodeFunctionSignature('myMethod(uint256,string)')\n   *\n   * @method encodeFunctionSignature\n   * @memberof ABI\n   * @instance\n   * @param {string|object} functionSignature The function signature or the JSON interface object of the function to encode. If this is a string, it has to be in the form `function(type, type,...)`, e.g: `myFunction(uint256,uint32[],bytes10,bytes)`.\n   * @return {string} function signature\n   */\n  encodeFunctionSignature(functionSignature) {\n    if (_.isObject(functionSignature)) {\n      functionSignature = utils._jsonInterfaceMethodToString(functionSignature);\n    }\n\n    return utils.sha3(functionSignature).slice(0, 10);\n  }\n  /**\n   * Encodes the event signature to its ABI signature, which is the sha3 hash of the event name including input parameter types.\n   *\n   * @example\n   * caver.abi.encodeEventSignature({ name: 'myEvent', type: 'event', inputs: [{ type: 'uint256', name: 'myNumber' },{ type: 'string', name: 'mystring' }]})\n   *\n   * caver.abi.encodeEventSignature('myEvent(uint256,bytes32)')\n   *\n   * @method encodeEventSignature\n   * @memberof ABI\n   * @instance\n   * @param {string|object} eventSignature The event signature or the JSON interface object of the event to encode. If this is a string, it has to be in the form `event(type,type,...)`, e.g: `myEvent(uint256,uint32[],bytes10,bytes)`.\n   * @return {string} event signature\n   */\n\n\n  encodeEventSignature(eventSignature) {\n    if (_.isObject(eventSignature)) {\n      eventSignature = utils._jsonInterfaceMethodToString(eventSignature);\n    }\n\n    return utils.sha3(eventSignature);\n  }\n  /**\n   * Encodes a parameter based on its type to its ABI representation.\n   *\n   * @example\n   * caver.abi.encodeParameter('uint256', '2345675643')\n   * caver.abi.encodeParameter('bytes32[]', [caver.utils.rightPad('0xdf3234', 64), caver.utils.rightPad('0xfdfd', 64)])\n   * caver.abi.encodeParameter('tuple(bytes32,bool)', ['0xabdef18710a18a18abdef18710a18a18abdef18710a18a18abdef18710a18a18', true])\n   *\n   * @method encodeParameter\n   * @memberof ABI\n   * @instance\n   * @param {string|object} type The type of the parameter, see the {@link http://solidity.readthedocs.io/en/develop/types.html|solidity documentation}  for a list of types.\n   * @param {*} param The actual parameter to encode.\n   * @return {string} encoded plain param\n   */\n\n\n  encodeParameter(type, param) {\n    return this.encodeParameters([type], [param]);\n  }\n  /**\n   * Encodes function parameters based on its JSON interface object.\n   *\n   * @example\n   * caver.abi.encodeParameters(['uint256','string'], ['2345675643', 'Hello!%'])\n   *\n   * caver.abi.encodeParameters(\n   *      ['tuple(bytes32,bool)', 'tuple(bool,address)'],\n   *      [['0xabdef18710a18a18abdef18710a18a18abdef18710a18a18abdef18710a18a18', true], [true, '0x77656c636f6d6520746f20657468657265756d2e']]\n   * )\n   *\n   * caver.abi.encodeParameters(\n   *   [\n   *       {\n   *           components: [{ name: 'a', type: 'bytes32' }, { name: 'b', type: 'bool' }],\n   *           name: 'tupleExample',\n   *           type: 'tuple',\n   *       },\n   *       {\n   *           components: [{ name: 'c', type: 'bool' }, { name: 'd', type: 'address' }],\n   *           name: 'tupleExample2',\n   *          type: 'tuple',\n   *      },\n   *  ],\n   *  [\n   *      ['0xabdef18710a18a18abdef18710a18a18abdef18710a18a18abdef18710a18a18', true],\n   *      [true, '0x77656c636f6d6520746f20657468657265756d2e']\n   *  ]\n   *)\n   *\n   * @method encodeParameters\n   * @memberof ABI\n   * @instance\n   * @param {Array.<string|object>} types An array with types or a JSON interface of a function. See the {@link http://solidity.readthedocs.io/en/develop/types.html|solidity documentation} for a list of types.\n   * @param {Array.<*>} params The parameters to encode.\n   * @return {string} encoded list of params\n   */\n\n\n  encodeParameters(types, params) {\n    const self = this;\n    types = self.mapTypes(types);\n    params = params.map(function (param, index) {\n      let type = types[index]; // { components: [[Object], [Object]], name: 'b', type: 'tuple' }\n\n      if (typeof type === 'object' && type.type) {\n        // We may get a named type of shape {name, type}\n        type = type.type;\n      }\n\n      param = self.formatParam(type, param); // If the type is string but number comes in, ethersAbiCoder ignores the type and encodes successfully.\n      // To avoid invalid encoding value, adding error handling.\n\n      if (type === 'string' && typeof param !== 'string') throw new Error(\"Invalid parameter: Parameter value and type do not match.\"); // Format params for tuples\n\n      if (typeof type === 'string' && type.includes('tuple')) {\n        const coder = ethersAbiCoder._getCoder(ParamType.from(type)); // eslint-disable-next-line no-shadow\n\n\n        const modifyParams = (coder, param) => {\n          if (coder.name === 'array') {\n            return param.map(p => {\n              // `coder.type.replace('[]','')` can handle'tuple(string,string)[]', but cannot handle `tuple(string,string)[3]'.\n              // Therefore, in order to handle tuple arrays of fixed length, the logic is changed to handle strings using regular expression expressions.\n              const replacedType = coder.type.replace(/\\[[1-9]*\\]/g, '');\n              const parameterType = ParamType.from(replacedType);\n\n              const gotCoder = ethersAbiCoder._getCoder(parameterType);\n\n              modifyParams(gotCoder, p);\n            });\n          }\n\n          coder.coders.forEach((c, i) => {\n            if (c.name === 'tuple') {\n              modifyParams(c, param[i]);\n            } else {\n              param[i] = self.formatParam(c.name, param[i]);\n            }\n          });\n        };\n\n        modifyParams(coder, param);\n      }\n\n      return param;\n    });\n    return ethersAbiCoder.encode(types, params);\n  }\n  /**\n   * Should be used to encode smart contract deployment with constructor arguments.\n   *\n   * @example\n   * // There is no argument for constructor\n   * caver.abi.encodeContractDeploy([\n   *     { \"constant\": true, \"inputs\": [], \"name\": \"count\", \"outputs\": [ { \"name\": \"\", \"type\": \"uint256\" } ], \"payable\": false, \"stateMutability\": \"view\", \"type\": \"function\" },\n   *     { \"constant\": true, \"inputs\": [], \"name\": \"getBlockNumber\", \"outputs\": [ { \"name\": \"\", \"type\": \"uint256\" } ], \"payable\": false, \"stateMutability\": \"view\", \"type\": \"function\" },\n   *     { \"constant\": false, \"inputs\": [ { \"name\": \"_count\", \"type\": \"uint256\" } ], \"name\": \"setCount\", \"outputs\": [], \"payable\": false, \"stateMutability\": \"nonpayable\", \"type\": \"function\" }\n   * ],'0x{byte code}')\n   *\n   * // There is one argument for constructor\n   * caver.abi.encodeContractDeploy([\n   *     { \"constant\": true, \"inputs\": [], \"name\": \"count\", \"outputs\": [ { \"name\": \"\", \"type\": \"uint256\" } ], \"payable\": false, \"stateMutability\": \"view\", \"type\": \"function\" },\n   *     { \"constant\": true, \"inputs\": [], \"name\": \"getBlockNumber\", \"outputs\": [ { \"name\": \"\", \"type\": \"uint256\" } ], \"payable\": false, \"stateMutability\": \"view\", \"type\": \"function\" },\n   *     { \"constant\": false, \"inputs\": [ { \"name\": \"_count\", \"type\": \"uint256\" } ], \"name\": \"setCount\", \"outputs\": [], \"payable\": false, \"stateMutability\": \"nonpayable\", \"type\": \"function\" },\n   *     { \"inputs\": [ { \"name\": \"_a\", \"type\": \"uint256\" } ], \"payable\": false, \"stateMutability\": \"nonpayable\", \"type\": \"constructor\" }\n   * ],'0x{byte code}', 1)\n   *\n   * @method encodeContractDeploy\n   * @memberof ABI\n   * @instance\n   * @param {Array.<object>} jsonInterface The JSON interface of the contract.\n   * @param {string} bytecode A bytecode of smart contract to be deployed.\n   * @param {...*} [args] Arguments to pass to the constructor.\n   * @return {string} bytecode + args\n   */\n\n\n  encodeContractDeploy(jsonInterface, bytecode, ...args) {\n    if (!jsonInterface) {\n      throw new Error('jsonInterface should be provided for encoding contract deployment.');\n    }\n\n    if (!bytecode) {\n      throw new Error('bytecode should be provided for encoding contract deployment.');\n    }\n\n    const constructorInterface = jsonInterface.filter(({\n      type\n    }) => type === 'constructor')[0];\n    const constructorInputs = constructorInterface && constructorInterface.inputs; // If constructor doesn't exist in smart contract, only bytecode is needed for deploying.\n\n    if (!constructorInterface || !constructorInputs || _.isEmpty(constructorInputs)) {\n      return bytecode;\n    }\n\n    if (constructorInputs.length !== args.length) {\n      throw new Error(\"invalid number of parameters for deploying. Got \".concat(args.length, \" expected \").concat(constructorInputs.length, \"!\"));\n    }\n\n    const constructorTypes = constructorInputs.map(({\n      type\n    }) => type);\n    return bytecode + this.encodeParameters(constructorTypes, args).replace('0x', '');\n  }\n  /**\n   * Map types if simplified format is used\n   *\n   * @method mapTypes\n   * @memberof ABI\n   * @ignore\n   * @instance\n   * @param {Array} types\n   * @return {Array}\n   */\n\n\n  mapTypes(types) {\n    const self = this;\n    const mappedTypes = [];\n    types.forEach(function (type) {\n      // Remap `function` type params to bytes24 since Ethers does not\n      // recognize former type. Solidity docs say `Function` is a bytes24\n      // encoding the contract address followed by the function selector hash.\n      if (typeof type === 'object' && type.type === 'function') {\n        type = { ...type,\n          type: 'bytes24'\n        };\n      }\n\n      if (self.isSimplifiedStructFormat(type)) {\n        const structName = Object.keys(type)[0];\n        mappedTypes.push(Object.assign(self.mapStructNameAndType(structName), {\n          components: self.mapStructToCoderFormat(type[structName])\n        }));\n        return;\n      }\n\n      mappedTypes.push(type);\n    });\n    return mappedTypes;\n  }\n  /**\n   * Check if type is simplified struct format\n   *\n   * @method isSimplifiedStructFormat\n   * @memberof ABI\n   * @ignore\n   * @instance\n   * @param {string|Object} type\n   * @returns {boolean}\n   */\n\n\n  isSimplifiedStructFormat(type) {\n    return typeof type === 'object' && typeof type.components === 'undefined' && typeof type.name === 'undefined';\n  }\n  /**\n   * Maps the correct tuple type and name when the simplified format in encode/decodeParameter is used\n   *\n   * @method mapStructNameAndType\n   * @memberof ABI\n   * @ignore\n   * @instance\n   * @param {string} structName\n   * @return {{type: string, name: *}}\n   */\n\n\n  mapStructNameAndType(structName) {\n    let type = 'tuple';\n\n    if (structName.indexOf('[]') > -1) {\n      type = 'tuple[]';\n      structName = structName.slice(0, -2);\n    }\n\n    return {\n      type: type,\n      name: structName\n    };\n  }\n  /**\n   * Maps the simplified format in to the expected format of the ABI\n   *\n   * @method mapStructToCoderFormat\n   * @memberof ABI\n   * @ignore\n   * @instance\n   * @param {object} struct\n   * @return {Array}\n   */\n\n\n  mapStructToCoderFormat(struct) {\n    const self = this;\n    const components = [];\n    Object.keys(struct).forEach(function (key) {\n      if (typeof struct[key] === 'object') {\n        components.push(Object.assign(self.mapStructNameAndType(key), {\n          components: self.mapStructToCoderFormat(struct[key])\n        }));\n        return;\n      }\n\n      components.push({\n        name: key,\n        type: struct[key]\n      });\n    });\n    return components;\n  }\n  /**\n   * Handle some formatting of params for backwards compatability with Ethers V4\n   *\n   * @method formatParam\n   * @memberof ABI\n   * @ignore\n   * @param {string} - type\n   * @param {any} - param\n   * @return {string|Array.<string>} - The formatted param\n   */\n\n\n  formatParam(type, param) {\n    const paramTypeBytes = /^bytes([0-9]*)$/;\n    const paramTypeBytesArray = /^bytes([0-9]*)\\[\\]$/;\n    const paramTypeNumber = /^(u?int)([0-9]*)$/;\n    const paramTypeNumberArray = /^(u?int)([0-9]*)\\[\\]$/; // Format BN to string\n\n    if (utils.isBN(param) || utils.isBigNumber(param)) {\n      return param.toString(10);\n    }\n\n    if (type.match(paramTypeBytesArray) || type.match(paramTypeNumberArray)) {\n      return param.map(p => this.formatParam(type.replace('[]', ''), p));\n    } // Format correct width for u?int[0-9]*\n\n\n    let match = type.match(paramTypeNumber);\n\n    if (match) {\n      const size = parseInt(match[2] || '256');\n\n      if (size / 8 < param.length) {\n        // pad to correct bit width\n        param = utils.leftPad(param, size);\n      }\n    } // Format correct length for bytes[0-9]+\n\n\n    match = type.match(paramTypeBytes);\n\n    if (match) {\n      if (Buffer.isBuffer(param)) {\n        param = utils.toHex(param);\n      } // format to correct length\n\n\n      const size = parseInt(match[1]);\n\n      if (size) {\n        let maxSize = size * 2;\n\n        if (param.substring(0, 2) === '0x') {\n          maxSize += 2;\n        }\n\n        if (param.length < maxSize) {\n          // pad to correct length\n          param = utils.rightPad(param, size * 2);\n        }\n      } // format odd-length bytes to even-length\n\n\n      if (param.length % 2 === 1) {\n        param = \"0x0\".concat(param.substring(2));\n      }\n    }\n\n    return param;\n  }\n  /**\n   * Encodes a function call from its json interface and parameters.\n   *\n   * @example\n   * caver.abi.encodeFunctionCall({\n   *     name: 'myMethod',\n   *     type: 'function',\n   *     inputs: [{\n   *         type: 'uint256',\n   *         name: 'myNumber'\n   * },{\n   *         type: 'string',\n   *         name: 'mystring'\n   *     }]\n   * }, ['2345675643', 'Hello!%'])\n   *\n   * @method encodeFunctionCall\n   * @memberof ABI\n   * @instance\n   * @param {object} jsonInterface The JSON interface object of a function.\n   * @param {Array.<*>} [params] The parameters to encode.\n   * @return {string} The encoded ABI for this function call\n   */\n\n\n  encodeFunctionCall(jsonInterface, params) {\n    params = params || [];\n    return this.encodeFunctionSignature(jsonInterface) + this.encodeParameters(jsonInterface.inputs, params).replace('0x', '');\n  }\n  /**\n   * Decodes a function call from its abi object of a function and returns parameters.\n   * If the function signature of the `abi` passed as a parameter does not match the function signature of the `functionCall`, an error is returned.\n   *\n   * @example\n   * const abi = {\n   *    name: 'myMethod',\n   *    type: 'function',\n   *    inputs: [\n   *        {\n   *            type: 'uint256',\n   *           name: 'myNumber',\n   *       },\n   *       {\n   *           type: 'string',\n   *           name: 'mystring',\n   *       },\n   *   ],\n   * }\n   * const functionCall = '0x24ef0...'\n   * caver.abi.decodeFunctionCall(abi, functionCall)\n   *\n   * @method decodeFunctionCall\n   * @memberof ABI\n   * @instance\n   * @param {object} abi The abi object of a function.\n   * @param {string} functionCall The encoded function call string.\n   * @return {object} An object which includes plain params. You can use `result[0]` as it is provided to be accessed like an array in the order of the parameters.\n   */\n\n\n  decodeFunctionCall(abi, functionCall) {\n    functionCall = utils.addHexPrefix(functionCall);\n    if (!_.isObject(abi) || _.isArray(abi)) throw new Error(\"Invalid abi parameter type: To decode function call, you need to pass an abi object of the function as a first parameter.\");\n    if (!abi.name || !abi.inputs) throw new Error(\"Insufficient info in abi object: The function name and inputs must be defined inside the abi function object.\");\n    const funcSig = this.encodeFunctionSignature(abi);\n    const extractFuncSig = functionCall.slice(0, funcSig.length);\n    if (funcSig !== extractFuncSig) throw new Error(\"Invalid function signature: The function signature of the abi as a parameter and the function signatures extracted from the function call string do not match.\");\n    return this.decodeParameters(abi.inputs, \"0x\".concat(functionCall.slice(funcSig.length)));\n  }\n  /**\n   * Decodes an ABI encoded parameter to its JavaScript type.\n   *\n   * @example\n   * caver.abi.decodeParameter('uint256', '0x0000000000000000000000000000000000000000000000000000000000000010')\n   *\n   * caver.abi.decodeParameter('string', '0x0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000848656c6c6f212521000000000000000000000000000000000000000000000000')\n   *\n   * caver.abi.decodeParameter('tuple(bytes32,bool)', '0xabdef18710a18a18abdef18710a18a18abdef18710a18a18abdef18710a18a180000000000000000000000000000000000000000000000000000000000000001')\n   *\n   * caver.abi.decodeParameter(\n   *     {\n   *         components: [{ name: 'a', type: 'bytes32' }, { name: 'b', type: 'bool' }],\n   *         name: 'tupleExample',\n   *         type: 'tuple',\n   *     }, '0xabdef18710a18a18abdef18710a18a18abdef18710a18a18abdef18710a18a180000000000000000000000000000000000000000000000000000000000000001'\n   * )\n   *\n   * @method decodeParameter\n   * @memberof ABI\n   * @instance\n   * @param {string|object} type The type of the parameter, see the {@link http://solidity.readthedocs.io/en/develop/types.html|solidity documentation} for a list of types.\n   * @param {string} encodedString The ABI byte code to decode.\n   * @return {string} plain param\n   */\n\n\n  decodeParameter(type, encodedString) {\n    return this.decodeParameters([type], encodedString)[0];\n  }\n  /**\n   * Decodes ABI encoded parameters to its JavaScript types.\n   *\n   * @example\n   * caver.abi.decodeParameters(['string', 'uint256'], '0x000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000ea000000000000000000000000000000000000000000000000000000000000000848656c6c6f212521000000000000000000000000000000000000000000000000')\n   *\n   * caver.abi.decodeParameters(\n   *  ['tuple(bytes32,bool)', 'tuple(bool,address)'],\n   *  '0xabdef18710a18a18abdef18710a18a18abdef18710a18a18abdef18710a18a180000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000100000000000000000000000077656c636f6d6520746f20657468657265756d2e'\n   * )\n   *\n   * caver.abi.decodeParameters([{\n   *     type: 'string',\n   *     name: 'mystring'\n   * },{\n   *     type: 'uint256',\n   *     name: 'myNumber'\n   * }], '0x000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000ea000000000000000000000000000000000000000000000000000000000000000848656c6c6f212521000000000000000000000000000000000000000000000000')\n   *\n   * caver.abi.decodeParameters(\n   *     [\n   *         {\n   *             components: [{ name: 'a', type: 'bytes32' }, { name: 'b', type: 'bool' }],\n   *             name: 'tupleExample',\n   *             type: 'tuple',\n   *         },\n   *         {\n   *             components: [{ name: 'c', type: 'bool' }, { name: 'd', type: 'address' }],\n   *             name: 'tupleExample2',\n   *             type: 'tuple',\n   *         },\n   *     ],\n   *     '0xabdef18710a18a18abdef18710a18a18abdef18710a18a18abdef18710a18a180000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000100000000000000000000000077656c636f6d6520746f20657468657265756d2e'\n   * )\n   *\n   * @method decodeParameters\n   * @memberof ABI\n   * @instance\n   * @param {Array.<string|object>} typesArray An array with types or an array of JSON interface outputs. See the {@link http://solidity.readthedocs.io/en/develop/types.html|solidity documentation} for a list of types.\n   * @param {string} encodedString The ABI byte code to decode.\n   * @return {object} An object which includes plain params. You can use `result[0]` as it is provided to be accessed like an array in the order of the parameters.\n   */\n\n\n  decodeParameters(outputs, encodedString) {\n    return this.decodeParametersWith(outputs, encodedString, false);\n  }\n  /**\n   * Should be used to decode list of params\n   *\n   * @method decodeParametersWith\n   * @memberof ABI\n   * @instance\n   * @ignore\n   * @param {Array} outputs\n   * @param {string} bytes\n   * @param {Boolean} loose must be passed for decoding bytes and string parameters for logs emitted with solc 0.4.x\n   *                        Please refer to https://github.com/ChainSafe/web3.js/commit/e80337e16e5c04683fc40148378775234c28e0fb.\n   * @return {object} An object which includes plain params. You can use `result[0]` as it is provided to be accessed like an array in the order of the parameters.\n   */\n\n\n  decodeParametersWith(outputs, bytes, loose) {\n    if (outputs.length > 0 && (!bytes || bytes === '0x' || bytes === '0X')) {\n      throw new Error(\"Returned values aren't valid, did it run Out of Gas? \" + 'You might also see this error if you are not using the ' + 'correct ABI for the contract you are retrieving data from, ' + 'requesting data from a block number that does not exist, ' + 'or querying a node which is not fully synced.');\n    }\n\n    const res = ethersAbiCoder.decode(this.mapTypes(outputs), \"0x\".concat(bytes.replace(/0x/i, '')), loose);\n    const returnValue = new Result();\n    returnValue.__length__ = 0;\n    outputs.forEach(function (output, i) {\n      let decodedValue = res[returnValue.__length__];\n      decodedValue = decodedValue === '0x' ? null : decodedValue;\n      returnValue[i] = decodedValue;\n\n      if (_.isObject(output) && output.name) {\n        returnValue[output.name] = decodedValue;\n      }\n\n      returnValue.__length__++;\n    });\n    return returnValue;\n  }\n  /**\n   * Decodes ABI encoded log data and indexed topic data.\n   *\n   * @example\n   * caver.abi.decodeLog(\n   *     [\n   *         {\n   *             type: 'string',\n   *             name: 'mystring'\n   *         },{\n   *             type: 'uint256',\n   *             name: 'myNumber',\n   *             indexed: true\n   *         },{\n   *             type: 'uint8',\n   *             name: 'mySmallNumber',\n   *             indexed: true\n   *          }\n   *     ],\n   *     '0x0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000748656c6c6f252100000000000000000000000000000000000000000000000000',\n   *      ['0x000000000000000000000000000000000000000000000000000000000000f310', '0x0000000000000000000000000000000000000000000000000000000000000010']\n   * )\n   *\n   *\n   * @method decodeLog\n   * @memberof ABI\n   * @instance\n   * @param {Array.<object>} inputs An array of JSON interface inputs. See the solidity documentation for a list of types.\n   * @param {string} data The ABI byte code in the data field of a log.\n   * @param {*} topics An array of the index parameter topics of the log. This array doesn't have topic[0] if it is a non-anonymous event, or otherwise, it has topic[0].\n   * @return {object} An object which includes plain params. You can use `result[0]` as it is provided to be accessed like an array in the order of the parameters.\n   */\n\n\n  decodeLog(inputs, data, topics) {\n    const _this = this;\n\n    topics = _.isArray(topics) ? topics : [topics];\n    data = data || '';\n    const notIndexedInputs = [];\n    const indexedParams = [];\n    let topicCount = 0; // TODO check for anonymous logs?\n\n    inputs.forEach(function (input, i) {\n      if (input.indexed) {\n        indexedParams[i] = ['bool', 'int', 'uint', 'address', 'fixed', 'ufixed'].find(function (staticType) {\n          return input.type.indexOf(staticType) !== -1;\n        }) ? _this.decodeParameter(input.type, topics[topicCount]) : topics[topicCount];\n        topicCount++;\n      } else {\n        notIndexedInputs[i] = input;\n      }\n    });\n    const nonIndexedData = data;\n    const notIndexedParams = nonIndexedData ? this.decodeParametersWith(notIndexedInputs, nonIndexedData, true) : [];\n    const returnValue = new Result();\n    returnValue.__length__ = 0;\n    inputs.forEach(function (res, i) {\n      returnValue[i] = res.type === 'string' ? '' : null;\n\n      if (typeof notIndexedParams[i] !== 'undefined') {\n        returnValue[i] = notIndexedParams[i];\n      }\n\n      if (typeof indexedParams[i] !== 'undefined') {\n        returnValue[i] = indexedParams[i];\n      }\n\n      if (res.name) {\n        returnValue[res.name] = returnValue[i];\n      }\n\n      returnValue.__length__++;\n    });\n    return returnValue;\n  }\n\n}\n/** @instance */\n\n\nconst abi = new ABI();\nmodule.exports = abi;","map":null,"metadata":{},"sourceType":"script"}