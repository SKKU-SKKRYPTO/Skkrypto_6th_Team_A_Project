{"ast":null,"code":"var _slicedToArray = require(\"/Users/kimdoheon/IdeaProjects/skku/frontend/node_modules/@babel/runtime/helpers/slicedToArray\");\n\n/*\n Modifications copyright 2018 The caver-js Authors\n This file is part of web3.js.\n\n web3.js is free software: you can redistribute it and/or modify\n it under the terms of the GNU Lesser General Public License as published by\n the Free Software Foundation, either version 3 of the License, or\n (at your option) any later version.\n\n web3.js is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU Lesser General Public License for more details.\n\n You should have received a copy of the GNU Lesser General Public License\n along with web3.js.  If not, see <http://www.gnu.org/licenses/>.\n\n This file is derived from web3.js/packages/web3-utils/src/utils.js (2019/06/12).\n Modified and improved for the caver-js development.\n */\n\n/**\n * @file utils.js\n * @author Fabian Vogelsteller <fabian@ethereum.org>\n * @date 2017\n */\nconst _ = require('lodash');\n\nconst BN = require('bn.js');\n\nconst BigNumber = require('bignumber.js');\n\nconst numberToBN = require('number-to-bn');\n\nconst utf8 = require('utf8');\n\nconst Hash = require('eth-lib/lib/hash');\n\nconst RLP = require('eth-lib/lib/rlp');\n\nconst Account = require('eth-lib/lib/account');\n\nconst elliptic = require('elliptic');\n\nconst secp256k1 = new elliptic.ec('secp256k1');\nconst txTypeToString = {\n  '0x20': 'ACCOUNT_UPDATE',\n  '0x21': 'FEE_DELEGATED_ACCOUNT_UPDATE',\n  '0x22': 'FEE_DELEGATED_ACCOUNT_UPDATE_WITH_RATIO',\n  '0x08': 'VALUE_TRANSFER',\n  '0x10': 'VALUE_TRANSFER_MEMO',\n  '0x09': 'FEE_DELEGATED_VALUE_TRANSFER',\n  '0x0a': 'FEE_DELEGATED_VALUE_TRANSFER_WITH_RATIO',\n  '0x11': 'FEE_DELEGATED_VALUE_TRANSFER_MEMO',\n  '0x12': 'FEE_DELEGATED_VALUE_TRANSFER_MEMO_WITH_RATIO',\n  '0x28': 'SMART_CONTRACT_DEPLOY',\n  '0x29': 'FEE_DELEGATED_SMART_CONTRACT_DEPLOY',\n  '0x2a': 'FEE_DELEGATED_SMART_CONTRACT_DEPLOY_WITH_RATIO',\n  '0x30': 'SMART_CONTRACT_EXECUTION',\n  '0x31': 'FEE_DELEGATED_SMART_CONTRACT_EXECUTION',\n  '0x32': 'FEE_DELEGATED_SMART_CONTRACT_EXECUTION_WITH_RATIO',\n  '0x38': 'CANCEL',\n  '0x39': 'FEE_DELEGATED_CANCEL',\n  '0x3a': 'FEE_DELEGATED_CANCEL_WITH_RATIO',\n  '0x48': 'CHAIN_DATA_ANCHORING'\n};\nconst HASH_LENGTH = 66;\n/**\n * Returns `true` if parameter is a BN instance, otherwise `false`.\n *\n * @example\n * const bn = new caver.utils.BN(10)\n * const result = caver.utils.isBN(bn)\n *\n * @memberof module:utils\n * @inner\n *\n * @param {*} bn\n * @return {boolean} `true` if a given value is a `BN.js` instance.\n */\n\nconst isBN = function (bn) {\n  return BN.isBN(bn);\n};\n/**\n * Returns `true` if object is a BigNumber instance, otherwise `false`.\n *\n * @example\n * const bigNumber = new caver.utils.BigNumber(10)\n * const result = caver.utils.isBigNumber(bigNumber)\n *\n * @memberof module:utils\n * @inner\n *\n * @param {*} bigNumber\n * @return {boolean} `true` if a given value is a `Bignumber.js` instance.\n */\n\n\nconst isBigNumber = function (bigNumber) {\n  return BigNumber.isBigNumber(bigNumber);\n};\n/**\n * Safely converts any given value (including `Bignumber.js` instances) into a `BN.js` instance, for handling big numbers in JavaScript.\n *\n * @example\n * const result = caver.utils.toBN(num)\n *\n * @memberof module:utils\n * @inner\n *\n * @param {number|string|BN|BigNumber} number The number to convert to a BN.js instance.\n * @return {BN} The {@link https://github.com/indutny/bn.js/|BN.js} instance.\n */\n\n\nfunction toBN(number) {\n  try {\n    return numberToBN.apply(null, arguments);\n  } catch (e) {\n    throw new Error(\"\".concat(e, \" Given value: \\\"\").concat(number, \"\\\"\"));\n  }\n}\n/**\n * Converts a negative number into a two's complement.\n *\n * @example\n * const result = caver.utils.toTwosComplement(num)\n *\n * @memberof module:utils\n * @inner\n *\n * @param {number|string|BN|BigNumber} number The number to convert.\n * @return {string} The converted hex string.\n */\n\n\nconst toTwosComplement = function (number) {\n  return \"0x\".concat(toBN(number).toTwos(256).toString(16, 64));\n};\n/**\n * Checks if a given string is a valid Klaytn address.\n * It will also check the checksum if the address has upper and lowercase letters.\n *\n * @example\n * const result = caver.utils.isAddress('0x{address in hex}')\n *\n * @memberof module:utils\n * @inner\n *\n * @param {string} address An address string.\n * @return {boolean} `true` if a given string is a valid Klaytn address.\n */\n\n\nconst isAddress = function (address) {\n  // check if it has the basic requirements of an address\n  if (!/^(0x)?[0-9a-f]{40}$/i.test(address)) {\n    return false; // If it's ALL lowercase or ALL upppercase\n  }\n\n  if (/^(0x|0X)?[0-9a-f]{40}$/.test(address) || /^(0x|0X)?[0-9A-F]{40}$/.test(address)) {\n    return true; // Otherwise check each case\n  }\n\n  return checkAddressChecksum(address);\n};\n/**\n * Checks the checksum of a given address.\n * Will also return `false` on non-checksum addresses.\n *\n * @example\n * const result = caver.utils.checkAddressChecksum('0x{address in hex}')\n *\n * @memberof module:utils\n * @inner\n *\n * @param {string} address An address string.\n * @return {boolean}\n */\n\n\nconst checkAddressChecksum = function (address) {\n  // Check each case\n  address = address.replace(/^0x/i, '');\n  const addressHash = sha3(address.toLowerCase()).replace(/^0x/i, '');\n\n  for (let i = 0; i < 40; i++) {\n    // the nth letter should be uppercase if the nth digit of casemap is 1\n    if (parseInt(addressHash[i], 16) > 7 && address[i].toUpperCase() !== address[i] || parseInt(addressHash[i], 16) <= 7 && address[i].toLowerCase() !== address[i]) {\n      return false;\n    }\n  }\n\n  return true;\n};\n/**\n * Adds padding on the left of a string. Useful for adding paddings to HEX strings.\n *\n * @example\n * const result = caver.utils.padLeft('0x3456ff', 20) // '0x000000000000003456ff'\n * const result = caver.utils.padLeft('Hello', 20, 'x') // 'xxxxxxxxxxxxxxxHello'\n *\n * @memberof module:utils\n * @inner\n * @alias padLeft\n *\n * @param {string} string The string to add padding on the left.\n * @param {number} chars The number of characters the total string should have.\n * @param {string} [sign] The character sign to use, defaults to `0`.\n * @returns {string} The padded string.\n */\n\n\nconst leftPad = function (string, chars, sign) {\n  const hasPrefix = /^0x/i.test(string) || typeof string === 'number';\n  string = string.toString(16).replace(/^0x/i, '');\n  const padding = chars - string.length + 1 >= 0 ? chars - string.length + 1 : 0;\n  return (hasPrefix ? '0x' : '') + new Array(padding).join(sign || '0') + string;\n};\n/**\n * Adds padding on the right of a string, Useful for adding paddings to HEX strings.\n *\n * @example\n * const result = caver.utils.rightPad('0x3456ff', 20) // '0x3456ff00000000000000'\n * const result = caver.utils.rightPad('Hello', 20, 'x') // 'Helloxxxxxxxxxxxxxxx'\n *\n * @memberof module:utils\n * @inner\n * @alias padRight\n *\n * @param {string} string The string to add padding on the right.\n * @param {number} chars The number of characters the total string should have.\n * @param {string} [sign] The character sign to use, defaults to `0`.\n * @returns {string} The padded string.\n */\n\n\nconst rightPad = function (string, chars, sign) {\n  const hasPrefix = /^0x/i.test(string) || typeof string === 'number';\n  string = string.toString(16).replace(/^0x/i, '');\n  const padding = chars - string.length + 1 >= 0 ? chars - string.length + 1 : 0;\n  return (hasPrefix ? '0x' : '') + string + new Array(padding).join(sign || '0');\n};\n/**\n * Returns the HEX representation of a given UTF-8 string.\n *\n * @example\n * const result = caver.utils.utf8ToHex('I have 100€') // '0x49206861766520313030e282ac'\n *\n * @memberof module:utils\n * @inner\n *\n * @param {string} str A UTF-8 string to convert to a HEX string.\n * @returns {string} The HEX string.\n */\n\n\nconst utf8ToHex = function (str) {\n  str = utf8.encode(str);\n  let hex = ''; // remove \\u0000 padding from either side\n\n  str = str.replace(/^(?:\\u0000)*/, '');\n  str = str.split('').reverse().join('');\n  str = str.replace(/^(?:\\u0000)*/, '');\n  str = str.split('').reverse().join('');\n\n  for (let i = 0; i < str.length; i++) {\n    const code = str.charCodeAt(i); // if (code !== 0) {\n\n    const n = code.toString(16);\n    hex += n.length < 2 ? \"0\".concat(n) : n; // }\n  }\n\n  return \"0x\".concat(hex);\n};\n/**\n * Returns the UTF-8 string representation of a given HEX value.\n *\n * @example\n * const result = caver.utils.hexToUtf8('0x49206861766520313030e282ac') // 'I have 100€'\n *\n * @memberof module:utils\n * @inner\n *\n * @param {string} hex A HEX string to convert to a UTF-8 string.\n * @returns {string} The UTF-8 string.\n */\n\n\nconst hexToUtf8 = function (hex) {\n  if (!isHexStrict(hex)) {\n    throw new Error(\"The parameter \\\"\".concat(hex, \"\\\" must be a valid HEX string.\"));\n  }\n\n  let str = '';\n  let code = 0;\n  hex = hex.replace(/^0x/i, ''); // remove 00 padding from either side\n\n  hex = hex.replace(/^(?:00)*/, '');\n  hex = hex.split('').reverse().join('');\n  hex = hex.replace(/^(?:00)*/, '');\n  hex = hex.split('').reverse().join('');\n  const l = hex.length;\n\n  for (let i = 0; i < l; i += 2) {\n    code = parseInt(hex.substr(i, 2), 16); // if (code !== 0) {\n\n    str += String.fromCharCode(code); // }\n  }\n\n  return utf8.decode(str);\n};\n/**\n * Returns the number representation of a given HEX value.\n * Please note that this function is not useful for big numbers, rather use `caver.utils.toBN`.\n *\n * @example\n * const result = caver.utils.hexToNumber('0xea') // 234\n *\n * @memberof module:utils\n * @inner\n *\n * @param {string} A HEX string to be converted.\n * @return {number} The number representation of a given HEX value.\n */\n\n\nconst hexToNumber = function (value) {\n  if (!value) return value;\n\n  if (typeof value === 'string' && !isHexStrict(value)) {\n    throw new Error(\"Given value \\\"\".concat(value, \"\\\" is not a valid hex string.\"));\n  }\n\n  return toBN(value).toNumber();\n};\n/**\n * Returns the number representation of a given HEX value as a string.\n *\n * @example\n * const result = caver.utils.hexToNumberString('0xea') // '234'\n *\n * @memberof module:utils\n * @inner\n *\n * @param {string} A HEX string to be converted.\n * @return {string} The number as a string.\n */\n\n\nconst hexToNumberString = function (value) {\n  if (!value) return value;\n\n  if (_.isString(value) && !isHexStrict(value)) {\n    throw new Error(\"Given value \\\"\".concat(value, \"\\\" is not a valid hex string.\"));\n  }\n\n  return toBN(value).toString(10);\n};\n/**\n * Returns the HEX representation of a given number value.\n *\n * @example\n * const result = caver.utils.numberToHex(234) // '0xea'\n * const result = caver.utils.numberToHex('234')\n * const result = caver.utils.numberToHex(new caver.utils.BN(234))\n * const result = caver.utils.numberToHex(new caver.utils.BigNumber(234))\n *\n * @memberof module:utils\n * @inner\n *\n * @param {string|number|BN|BigNumber} value A number as string or number.\n * @return {string} The HEX value of the given number.\n */\n\n\nconst numberToHex = function (value) {\n  if (_.isNumber(value)) {\n    const bn = toBN(value);\n\n    try {\n      bn.toNumber();\n    } catch (e) {\n      throw new Error(\"\".concat(e.message, \": Number type cannot handle big number. Please use hex string or BigNumber/BN.\"));\n    }\n  }\n\n  if (_.isNull(value) || _.isUndefined(value)) {\n    return value;\n  }\n\n  if (!isFinite(value) && !isHexStrict(value)) {\n    throw new Error(\"Given input \\\"\".concat(value, \"\\\" is not a number.\"));\n  }\n\n  const number = toBN(value);\n  const result = number.toString(16);\n  return number.lt(new BN(0)) ? \"-0x\".concat(result.substr(1)) : \"0x\".concat(result);\n};\n/**\n * Returns a HEX string from a byte array.\n *\n * @example\n * const result = caver.utils.bytesToHex([ 72, 101, 108, 108, 111, 33, 36 ]) // '0x48656c6c6f2124'\n *\n * @memberof module:utils\n * @inner\n *\n * @param {Array} bytes A byte array to convert.\n * @return {string} The HEX string.\n */\n\n\nconst bytesToHex = function (bytes) {\n  const hex = [];\n\n  for (let i = 0; i < bytes.length; i++) {\n    // eslint-disable-next-line no-bitwise\n    hex.push((bytes[i] >>> 4).toString(16)); // eslint-disable-next-line no-bitwise\n\n    hex.push((bytes[i] & 0xf).toString(16));\n  }\n\n  return \"0x\".concat(hex.join(''));\n};\n/**\n * Returns a byte array from the given HEX string.\n *\n * @example\n * const result = caver.utils.hexToBytes('0x000000ea') // [ 0, 0, 0, 234 ]\n *\n * @memberof module:utils\n * @inner\n *\n * @param {string} hex A HEX string to be converted.\n * @return {Array.<number>} The byte array.\n */\n\n\nconst hexToBytes = function (hex) {\n  hex = hex.toString(16);\n\n  if (!isHexStrict(hex)) {\n    throw new Error(\"Given value \\\"\".concat(hex, \"\\\" is not a valid hex string.\"));\n  }\n\n  hex = hex.replace(/^0x/i, '');\n  const bytes = [];\n\n  for (let c = 0; c < hex.length; c += 2) {\n    bytes.push(parseInt(hex.substr(c, 2), 16));\n  }\n\n  return bytes;\n};\n/**\n * Converts any given value to HEX.\n * The numeric strings will be interpreted as numbers.\n * Text strings will be interpreted as UTF-8 strings.\n *\n * @example\n * const result = caver.utils.toHex('234') // '0xea'\n * const result = caver.utils.toHex(234) // '0xea'\n * const result = caver.utils.toHex(new caver.utils.BN('234')) // '0xea'\n * const result = caver.utils.toHex(new caver.utils.Bignumber('234')) // '0xea'\n * const result = caver.utils.toHex('I have 100€') // '0x49206861766520313030e282ac'\n *\n * @memberof module:utils\n * @inner\n *\n * @param {string|number|BN|BigNumber|Buffer} value The input to convert to HEX.\n * @return {string} The resulting HEX string.\n */\n\n/* eslint-disable complexity */\n\n\nconst toHex = function (value, returnType) {\n  if (Buffer.isBuffer(value)) {\n    return returnType ? 'buffer' : bufferToHex(value);\n  }\n\n  if (isAddress(value)) {\n    return returnType ? 'address' : \"0x\".concat(value.toLowerCase().replace(/^0x/i, ''));\n  }\n\n  if (_.isBoolean(value)) {\n    return returnType ? 'bool' : value ? '0x01' : '0x00';\n  }\n\n  if (_.isObject(value) && !isBigNumber(value) && !isBN(value)) {\n    return returnType ? 'string' : utf8ToHex(JSON.stringify(value));\n  } // if its a negative number, pass it through numberToHex\n\n\n  if (_.isString(value)) {\n    if (value.indexOf('-0x') === 0 || value.indexOf('-0X') === 0) {\n      return returnType ? 'int256' : numberToHex(value);\n    }\n\n    if (value.indexOf('0x') === 0 || value.indexOf('0X') === 0) {\n      return returnType ? 'bytes' : value;\n    }\n\n    if (!isFinite(value)) {\n      return returnType ? 'string' : utf8ToHex(value);\n    }\n  }\n\n  return returnType ? value < 0 ? 'int256' : 'uint256' : numberToHex(value);\n};\n/* eslint-enable complexity */\n\n/**\n * Converts buffer to 0x-prefixed hex string.\n *\n * @example\n * const result = caver.utils.bufferToHex(Buffer.from('5b9ac8', 'hex')) // '0x5b9ac8'\n *\n * @memberof module:utils\n * @inner\n *\n * @param {Buffer} buf A buffer to convert to hex string.\n * @return {string} The 0x-prefixed hex string.\n */\n\n\nconst bufferToHex = function (buf) {\n  buf = toBuffer(buf);\n  return \"0x\".concat(buf.toString('hex'));\n};\n/**\n * This function converts the input to a Buffer.\n * To convert an object into a Buffer using `caver.utils.toBuffer`, the object must implement `toArray` function.\n * For string type input, this function only works with a 0x-prefixed hex string.\n *\n * @example\n * const result = caver.utils.toBuffer(Buffer.alloc(0))\n * const result = caver.utils.toBuffer('0x1234')\n * const result = caver.utils.toBuffer(1)\n * const result = caver.utils.toBuffer([1,2,3])\n * const result = caver.utils.toBuffer(new caver.utils.BN(255))\n * const result = caver.utils.toBuffer(new caver.utils.BigNumber(255))\n * const result = caver.utils.toBuffer({toArray: function() {return [1,2,3,4]}}) // An object that implements `toArray` function\n * const result = caver.utils.toBuffer(null)\n * const result = caver.utils.toBuffer(undefined)\n *\n * @memberof module:utils\n * @inner\n *\n * @param {Buffer|Array.<number>|string|number|BN|BigNumber|object} input The value to be converted to a Buffer.\n * @return {Buffer} The value converted to Buffer type is returned.\n */\n\n\nconst toBuffer = function (input) {\n  if (Buffer.isBuffer(input)) return input;\n  if (input === null || input === undefined) return Buffer.alloc(0);\n  if (Array.isArray(input)) return Buffer.from(input);\n  if (isBigNumber(input)) input = toBN(input);\n  if (isBN(input)) return input.toArrayLike(Buffer);\n\n  if (_.isObject(input)) {\n    if (input.toArray && _.isFunction(input.toArray)) return Buffer.from(input.toArray());\n    throw new Error('To convert an object to a buffer, the toArray function must be implemented inside the object');\n  }\n\n  switch (typeof input) {\n    case 'string':\n      if (isHexStrict(input)) return Buffer.from(makeEven(input).replace('0x', ''), 'hex');\n      throw new Error(\"Failed to convert string to Buffer. 'toBuffer' function only supports 0x-prefixed hex string\");\n\n    case 'number':\n      return numberToBuffer(input);\n  }\n\n  throw new Error(\"Not supported type with \".concat(input));\n};\n/**\n * This function converts a number to a Buffer.\n * The {@link module:utils~toBuffer|caver.utils.toBuffer} has the same behavior as this function when the input is a number.\n *\n * @example\n * const result = caver.utils.numberToBuffer(1)\n * const result = caver.utils.numberToBuffer('2')\n * const result = caver.utils.numberToBuffer('0x3')\n * const result = caver.utils.numberToBuffer(new caver.utils.BN(4))\n * const result = caver.utils.numberToBuffer(new caver.utils.BigNumber(4))\n *\n * @memberof module:utils\n * @inner\n *\n * @param {number|string|BN|BigNumber} num A number to be converted to a Buffer.\n * @return {Buffer}\n */\n\n\nconst numberToBuffer = function (num) {\n  return Buffer.from(makeEven(numberToHex(num)).replace('0x', ''), 'hex');\n};\n/**\n * Checks if a given string is a HEX string.\n * Difference to {@link module:utils~isHex|caver.utils.isHex} is that it expects HEX to be prefixed with `0x`.\n *\n * @example\n * const result = caver.utils.isHexStrict('0xc1912') // true\n * const result = caver.utils.isHexStrict('c1912') // false\n * const result = caver.utils.isHexStrict('Hello') // false\n *\n * @memberof module:utils\n * @inner\n *\n * @param {string} hex The given HEX string.\n * @returns {boolean} `true` if a given string is a HEX string.\n */\n\n\nconst isHexStrict = function (hex) {\n  return (_.isString(hex) || _.isNumber(hex)) && /^(-)?0x[0-9a-f]*$/i.test(hex);\n};\n/**\n * Checks if a given string is a HEX string.\n *\n * @example\n * const result = caver.utils.isHex('0xc1912') // true\n * const result = caver.utils.isHex('c1912') // true\n * const result = caver.utils.isHex('Hello') // false\n *\n * @memberof module:utils\n * @inner\n *\n * @param {string} hex The given HEX string.\n * @returns {boolean} `true` if a given parameter is a HEX string.\n */\n\n\nconst isHex = function (hex) {\n  return (_.isString(hex) || _.isNumber(hex)) && /^(-0x|0x)?[0-9a-f]*$/i.test(hex);\n};\n/**\n * Checks if the given string is a hexadecimal transaction hash with or without prefix 0x\n * @deprecated since version v1.5.0\n * @ignore\n * @method isTxHash\n * @param {String} txHash given hexadecimal transaction hash\n * @return {Boolean}\n */\n\n\nconst isTxHash = txHash => isValidHash(txHash);\n/**\n * Returns `true` if the input is in 32-bytes hash format, otherwise it returns `false`.\n *\n * @example\n * const result = caver.utils.isValidHash('0xe9a11d9ef95fb437f75d07ce768d43e74f158dd54b106e7d3746ce29d545b550') // true\n * const result = caver.utils.isValidHash('e9a11d9ef95fb437f75d07ce768d43e74f158dd54b106e7d3746ce29d545b550') // true\n * const result = caver.utils.isValidHash('0x1') // false\n *\n * @memberof module:utils\n * @inner\n *\n * @param {string} hash The value to be examined that if it is in 32-bytes hash format or not.\n * @return {boolean} `true` means the input is in the format of 32-bytes hash.\n */\n\n\nconst isValidHash = hash => new RegExp(\"^(0x|0X)?[0-9a-fA-F]{\".concat(HASH_LENGTH - 2, \"}$\")).test(hash);\n/**\n * Checks if the given string is a hexadecimal transaction hash that starts with 0x\n * @deprecated since version v1.5.0\n * @ignore\n * @method isTxHashStrict\n * @param {String} txHash given hexadecimal transaction hash\n * @return {Boolean}\n */\n\n\nconst isTxHashStrict = txHash => isValidHashStrict(txHash);\n/**\n * Returns `true` if the input is in 0x-prefixed 32-bytes hash format, otherwise it returns `false`.\n * This function only looks at the input and determines if it is in the format of 0x-prefixed 32-bytes hash.\n * Difference to {@link module:utils~isValidHash|caver.utils.isValidHash} is that it expects HEX to be prefixed with 0x.\n *\n * @example\n * const result = caver.utils.isValidHashStrict('0xe9a11d9ef95fb437f75d07ce768d43e74f158dd54b106e7d3746ce29d545b550') // true\n * const result = caver.utils.isValidHashStrict('e9a11d9ef95fb437f75d07ce768d43e74f158dd54b106e7d3746ce29d545b550') // false\n * const result = caver.utils.isValidHashStrict('0x1') // false\n *\n * @memberof module:utils\n * @inner\n *\n * @param {string} hash The value to be examined that if it is in the format of 0x-prefixed 32-bytes hash or not.\n * @return {boolean} `true` means the input is in the format of 0x-prefixed 32-bytes hash.\n */\n\n\nconst isValidHashStrict = hash => new RegExp(\"^(0x|0X)[0-9a-fA-F]{\".concat(HASH_LENGTH - 2, \"}$\")).test(hash);\n/**\n * Returns `true` if the bloom is a valid bloom.\n *\n * @example\n * const result = caver.utils.isBloom('0x00000...')\n *\n * @memberof module:utils\n * @inner\n *\n * @param {string} bloom An encoded bloom filter.\n * @return {boolean} `true` means the input bloom parameter is valid.\n */\n\n\nconst isBloom = function (bloom) {\n  if (!/^(0x)?[0-9a-f]{512}$/i.test(bloom)) {\n    return false;\n  }\n\n  if (/^(0x)?[0-9a-f]{512}$/.test(bloom) || /^(0x)?[0-9A-F]{512}$/.test(bloom)) {\n    return true;\n  }\n\n  return false;\n};\n/**\n * Returns `true` if the topic is valid.\n *\n * @example\n * const result = caver.utils.isBloom('0x00000...')\n *\n * @memberof module:utils\n * @inner\n *\n * @param {string} hex An encoded topic.\n * @return {boolean}\n */\n\n\nconst isTopic = function (topic) {\n  if (!/^(0x)?[0-9a-f]{64}$/i.test(topic)) {\n    return false;\n  }\n\n  if (/^(0x)?[0-9a-f]{64}$/.test(topic) || /^(0x)?[0-9A-F]{64}$/.test(topic)) {\n    return true;\n  }\n\n  return false;\n};\n\nconst parsePredefinedBlockNumber = blockNumber => {\n  switch (blockNumber) {\n    case 'genesis':\n    case 'earliest':\n      return '0x0';\n\n    default:\n      return blockNumber;\n  }\n};\n/**\n * Returns `true` if the parameter is predefined block tag.\n *\n * @example\n * const result = caver.utils.isPredefinedBlockNumber('latest') // true\n *\n * @memberof module:utils\n * @inner\n *\n * @param {string} predefinedBlock The predefined block.\n * @return {boolean} `true` means predefinedBlock is valid predefined block tag.\n */\n\n\nconst isPredefinedBlockNumber = function (predefinedBlock) {\n  return predefinedBlock === 'latest' || predefinedBlock === 'pending' || predefinedBlock === 'earliest' || predefinedBlock === 'genesis';\n};\n/**\n * Validtes block number (or block tag string).\n *\n * The block number should be one of a type below:\n * 1) predefined block number ex:) 'latest', 'earliest', 'pending', 'genesis'\n * 2) hex\n * 3) finite number\n *\n * @example\n * const result = caver.utils.isValidBlockNumberCandidate('latest') // true\n * const result = caver.utils.isValidBlockNumberCandidate('0x1') // true\n * const result = caver.utils.isValidBlockNumberCandidate('1') // true\n * const result = caver.utils.isValidBlockNumberCandidate(1) // true\n *\n * @memberof module:utils\n * @inner\n *\n * @param  {string|number} blockNumber The block number to validate. This can be block number in number type or block tag(`latest`, `pending`, `earliest`, `genesis`) string.\n * @return {boolean} `true` means blockNumber is valid.\n */\n\n\nconst isValidBlockNumberCandidate = blockNumber => {\n  return isPredefinedBlockNumber(blockNumber) || isHexStrict(blockNumber) || Number.isFinite(Number(blockNumber));\n};\n/**\n * Hashes values to a sha3 hash using keccak 256\n *\n * To hash a HEX string the hex must have 0x in front.\n *\n * @return {String} the sha3 string\n */\n\n\nconst SHA3_NULL_S = '0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470';\n/**\n * Calculates the sha3 of the input.\n *\n * @example\n * const hash = caver.utils.sha3('234')\n *\n * @memberof module:utils\n * @inner\n *\n * @param {string} str - A string to hash.\n * @return {string} The result hash.\n */\n\nconst sha3 = function (value) {\n  // return null when value is not string type.\n  if (typeof value === 'number') return null;\n\n  if (isHexStrict(value) && /^0x/i.test(value.toString())) {\n    value = hexToBytes(value);\n  }\n\n  if (isBN(value)) {\n    value = value.toString(10);\n  }\n\n  const returnValue = Hash.keccak256(value);\n\n  if (returnValue === SHA3_NULL_S) {\n    return null;\n  }\n\n  return returnValue;\n}; // expose the under the hood keccak256\n\n\nsha3._Hash = Hash;\n/**\n * An object defines the AccountKeyLegacy.\n *\n * @example\n * { privateKey: '0x{private key}', address: '0x{address in hex}', type: '0x00' }\n *\n * @typedef {object} module:utils.ParsedPrivateKey\n * @property {string} privateKey - The private key string.\n * @property {string} address - The address string.\n * @property {string} type - The type string. Currently only `0x00` is supported.\n */\n\n/**\n * Parses private key string to { privateKey, address, type }.\n *\n * @example\n * const { privateKey, address, type } = caver.utils.parsePrivateKey('0x45a915e4d060149eb4365960e6a7a45f334393093061116b197e3240065ff2d8')\n * const { privateKey, address, type } = caver.utils.parsePrivateKey('0x45a915e4d060149eb4365960e6a7a45f334393093061116b197e3240065ff2d80x000xa94f5374fce5edbc8e2a8697c15331677e6ebf0b')\n *\n * @memberof module:utils\n * @inner\n *\n * @param {string} privateKey - A private key or KlaytnWalletKey string to parse.\n * @return {module:utils.ParsedPrivateKey} A parsed private key object.\n */\n\nfunction parsePrivateKey(privateKey) {\n  if (typeof privateKey !== 'string') throw new Error('The private key must be of type string');\n  const has0xPrefix = privateKey.slice(0, 2) === '0x';\n  privateKey = has0xPrefix ? privateKey.slice(2) : privateKey;\n\n  if (privateKey.length !== 110 && privateKey.length !== 64) {\n    throw new Error(\"Invalid private key(\".concat(privateKey, \")\"));\n  }\n\n  const parsedPrivateKey = privateKey.slice(0, 64);\n\n  if (!isHex(parsedPrivateKey)) {\n    throw new Error('Invalid private key format : privateKey must be in hex format.');\n  }\n\n  if (privateKey.length !== 110) {\n    return {\n      privateKey: \"0x\".concat(privateKey),\n      address: '',\n      type: ''\n    };\n  }\n\n  const type = privateKey.slice(66, 68);\n  if (type !== '00') throw new Error('Invalid type: Currently only type `0x00` is supported.');\n  if (!isKlaytnWalletKey(privateKey)) throw new Error(\"Invalid KlaytnWalletKey format.\");\n  const parsedAddress = privateKey.slice(68);\n  return {\n    privateKey: \"0x\".concat(parsedPrivateKey),\n    address: parsedAddress,\n    type: \"0x\".concat(type)\n  };\n}\n/**\n * Parses KlatynWalletKey to [ '0x{privateKey}', '0x{type}', '0x{address}' ].\n *\n * @example\n * const parsed = caver.utils.parseKlaytnWalletKey('0x45a915e4d060149eb4365960e6a7a45f334393093061116b197e3240065ff2d80x000xa94f5374fce5edbc8e2a8697c15331677e6ebf0b')\n *\n * @memberof module:utils\n * @inner\n *\n * @param {string} key - A KlaytnWalletKey string to parse.\n * @return {Array.<string>} An array that includes parsed KlaytnWalletKey.\n */\n\n\nfunction parseKlaytnWalletKey(key) {\n  if (!isKlaytnWalletKey(key)) throw new Error(\"Invalid KlaytnWalletKey format: \".concat(key));\n  const klaytnWalletKey = key.startsWith('0x') ? key.slice(2) : key;\n  const splitted = klaytnWalletKey.split('0x');\n  return [\"0x\".concat(splitted[0]), \"0x\".concat(splitted[1]), \"0x\".concat(splitted[2])];\n}\n/**\n * Validate a KlaytnWalletKey string.\n *\n * @example\n * const result = caver.utils.isKlaytnWalletKey('0x45a915e4d060149eb4365960e6a7a45f334393093061116b197e3240065ff2d80x000xa94f5374fce5edbc8e2a8697c15331677e6ebf0b')\n *\n * @memberof module:utils\n * @inner\n *\n * @param {string} privateKey - A KlaytnWalletKey string to validate.\n * @return {boolean} `true` means valid KlaytnWalletKey.\n */\n\n\nconst isKlaytnWalletKey = privateKey => {\n  if (!_.isString(privateKey)) return false;\n  const has0xPrefix = privateKey.slice(0, 2) === '0x';\n  privateKey = has0xPrefix ? privateKey.slice(2) : privateKey;\n\n  if (privateKey.length !== 110) {\n    return false;\n  }\n\n  const splited = privateKey.split('0x');\n  if (splited.length !== 3) return false;\n\n  for (let i = 0; i < splited.length; i++) {\n    if (!isHex(splited[i])) return false;\n\n    switch (i) {\n      case 0:\n        if (splited[i].length !== 64 || !isValidPrivateKey(splited[i])) return false;\n        break;\n\n      case 1:\n        if (splited[i].length !== 2 || splited[i] !== '00') return false;\n        break;\n\n      case 2:\n        if (splited[i].length !== 40 || !isAddress(splited[i])) return false;\n        break;\n    }\n  }\n\n  return true;\n};\n/**\n * Validate a private key string.\n *\n * @example\n * const result = caver.utils.isValidPrivateKey('0x45a915e4d060149eb4365960e6a7a45f334393093061116b197e3240065ff2d8')\n *\n * @memberof module:utils\n * @inner\n *\n * @param {string} privateKey - A private key string to validate.\n * @return {boolean} `true` means valid private key.\n */\n\n\nfunction isValidPrivateKey(privateKey) {\n  if (typeof privateKey !== 'string') return false;\n  const has0xPrefix = privateKey.slice(0, 2) === '0x';\n  privateKey = has0xPrefix ? privateKey.slice(2) : privateKey; // Private key validation 1: private key should be string and minimum length of it is 64.\n\n  if (privateKey.length !== 64 || !isHex(privateKey)) return false; // order n value in secp256k1. privateKey should be less than order n value.\n\n  const VALID_PRIVATE_KEY_LIMIT = 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141';\n  const VALID_PRIVATE_LOWER_BOUND = '0000000000000000000000000000000000000000000000000000000000000000';\n  return VALID_PRIVATE_LOWER_BOUND < privateKey.toUpperCase() && privateKey.toUpperCase() < VALID_PRIVATE_KEY_LIMIT;\n} // Check is 1)Number string or 2)Hex string or 3)Number.\n\n\nfunction isValidNSHSN(value) {\n  switch (typeof value) {\n    case 'number':\n      if (value < 0) {\n        return false;\n      }\n\n      break;\n\n    case 'string':\n      if (Number(value) != value && !isHexStrict(value)) {\n        return false;\n      }\n\n      break;\n\n    default:\n      return false;\n  }\n\n  return true;\n}\n\nconst rlpEncode = data => RLP.encode(data);\n\nconst rlpDecode = encodedData => RLP.decode(encodedData);\n/**\n * Converts from public key to x, y points.\n *\n * @example\n * const result = caver.utils.xyPointFromPublicKey('0x04019b186993b620455077b6bc37bf61666725d8d87ab33eb113ac0414cd48d78ff46e5ea48c6f22e8f19a77e5dbba9d209df60cbcb841b7e3e81fe444ba829831')\n *\n * @memberof module:utils\n * @inner\n *\n * @param {string} publicKey - A public key string.\n * @return {Array.<string>} An array with x, y points.\n */\n\n\nconst xyPointFromPublicKey = pub => {\n  let publicKey = pub;\n  if (isCompressedPublicKey(publicKey)) publicKey = decompressPublicKey(pub);\n  publicKey = publicKey.replace('0x', '');\n  if (publicKey.length === 130 && publicKey.slice(0, 2) === '04') publicKey = publicKey.slice(2);\n  if (publicKey.length !== 128) throw Error('Invalid public key'); // + 2 means '0x'\n\n  const pubX = \"0x\".concat(publicKey.slice(0, 64).replace(/^0+/, ''));\n  const pubY = \"0x\".concat(publicKey.slice(64).replace(/^0+/, ''));\n  return [pubX, pubY];\n};\n/**\n * Trims leading zero from 0x-prefixed hex string.\n *\n * @example\n * const result = caver.utils.trimLeadingZero('0x0000011') // '0x11'\n *\n * @memberof module:utils\n * @inner\n *\n * @param {string} hex - A hex string to trim.\n * @return {string} A hex string without leading zero.\n */\n\n\nconst trimLeadingZero = function (hex) {\n  while (hex && hex.startsWith('0x0')) {\n    hex = \"0x\".concat(hex.slice(3));\n  }\n\n  return hex;\n};\n/**\n * Returns a string to an even length.\n *\n * @example\n * const result = caver.utils.makeEven('0x011') // '0x0011'\n *\n * @memberof module:utils\n * @inner\n *\n * @param {string} hex - A hex string to make even.\n * @return {string} A string with even length.\n */\n\n\nconst makeEven = function (hex) {\n  if (hex.length % 2 === 1) {\n    hex = hex.replace('0x', '0x0');\n  }\n\n  return hex;\n};\n/**\n * Converts the signature to an array format.\n *\n * @example\n * const result = caver.utils.resolveSignature({ v: '0x0fe9', r: '0x02aca...', s: '0x20502...' })\n * const result = caver.utils.resolveSignature({ V: '0x0fe9', R: '0x02aca...', S: '0x20502...' })\n * const result = caver.utils.resolveSignature('0x7e85aaff6a6ef0730308af49f6b512741e61f958a21df387a0d0e8973fb40ca0307a8b87f6ac249f7218b4ee1a1d2f7d764ec2d20d9824e7b7b842dd214f139c7f6')\n *\n * @ignore\n * @param {string|object|Array.<string>|SignatureData} signature A signature string, object or array.\n * @return {Array.<string>} A signature array.\n */\n\n\nconst resolveSignature = signature => {\n  if (_.isArray(signature)) {\n    const _signature = _slicedToArray(signature, 3),\n          v = _signature[0],\n          r = _signature[1],\n          s = _signature[2];\n\n    return [v, r, s];\n  }\n\n  if (_.isObject(signature)) {\n    const v = signature.V || signature.v;\n    const r = signature.R || signature.r;\n    const s = signature.S || signature.s;\n    if (!v || !r || !s) throw new Error('v, r, s fields should exist in signature');\n    return [v, r, s];\n  }\n\n  if (_.isString(signature)) {\n    const v = \"0x\".concat(signature.slice(64 * 2 + 2));\n    const decoded = Account.decodeSignature(signature);\n    return [v, decoded[1], decoded[2]];\n  }\n};\n/**\n * Converts the signature to an `{ V, R, S }` format.\n * Klaytn Node uses `{ V, R, S }` format, so you can use this function to convert caver signature format to `{ V, R, S }`.\n *\n * @example\n * const result = caver.utils.transformSignaturesToObject([\n *     '0x7f6',\n *     '0x7e85aaff6a6ef0730308af49f6b512741e61f958a21df387a0d0e8973fb40ca0',\n *     '0x307a8b87f6ac249f7218b4ee1a1d2f7d764ec2d20d9824e7b7b842dd214f139c'\n * ])\n *\n * @ignore\n * @param {string|object|Array.<string>|SignatureData} signature A signature string, object or array.\n * @return {Klay.SignatureData} A signature object.\n */\n\n\nconst transformSignaturesToObject = signatures => {\n  let isSingular = false;\n  if (!signatures) throw new Error(\"Failed to transform signatures to object: invalid signatures \".concat(signatures)); // Input cases\n  // case 1. '0xf1998...'\n  // case 2. {V: '0x4e44', R: '0x1692a...', S: '0x277b9...'} or {v: '0x4e44', r: '0x1692a...', s: '0x277b9...'}\n  // case 3. ['0xf1998...', '0x53fe7...']\n  // case 4. ['0x4e44', '0x1692a...', '0x277b9...']\n  // case 5. [{V: '0x4e44', R: '0x1692a...', S: '0x277b9...'}, {v: '0x4e44', r: '0x1692a...', s: '0x277b9...'}]\n  // case 6. [['0x4e44', '0x1692a...', '0x277b9...'], ['0x4e44', '0x1692a...', '0x277b9...']]\n  // Transform a signature to an array of signatures to execute the same logic in the for loop below.\n\n  if (!_.isArray(signatures)) {\n    signatures = [signatures];\n    isSingular = true;\n  } else if (_.isString(signatures[0])) {\n    // This logic is performed for case 3 and case 4.\n    // In case 3, the signature string is in the array.\n    // In case 4, v, r, and s are separately included in the array.\n    // The signature string is a combination of v, r, and s, so the length of the signature string will be longer than 64.\n    // Hence, only case 4 will perform the below logic to form an array of signatures.\n    const stripped = signatures[0].replace('0x', '');\n\n    if (stripped.length <= 64) {\n      signatures = [signatures];\n      isSingular = true;\n    }\n  }\n\n  const ret = [];\n\n  for (const sig of signatures) {\n    const sigObj = {};\n\n    if (_.isArray(sig)) {\n      if (sig.length !== 3) throw new Error(\"Failed to transform signatures to object: invalid length of signature (\".concat(sig.length, \")\"));\n      if (isEmptySig(sig)) continue;\n\n      const _sig = _slicedToArray(sig, 3),\n            V = _sig[0],\n            R = _sig[1],\n            S = _sig[2];\n\n      sigObj.V = V;\n      sigObj.R = R;\n      sigObj.S = S;\n    } else if (_.isString(sig)) {\n      const decoded = Account.decodeSignature(sig).map(s => makeEven(trimLeadingZero(s)));\n      sigObj.V = decoded[0];\n      sigObj.R = decoded[1];\n      sigObj.S = decoded[2];\n    } else if (_.isObject(sig)) {\n      Object.keys(sig).map(key => {\n        if (key === 'v' || key === 'V' || key === '_v') {\n          sigObj.V = sig[key];\n        } else if (key === 'r' || key === 'R' || key === '_r') {\n          sigObj.R = sig[key];\n        } else if (key === 's' || key === 'S' || key === '_s') {\n          sigObj.S = sig[key];\n        } else {\n          throw new Error(\"Failed to transform signatures to object: invalid key(\".concat(key, \") is defined in signature object.\"));\n        }\n      });\n    } else {\n      throw new Error(\"Unsupported signature type: \".concat(typeof sig));\n    }\n\n    if (!sigObj.V || !sigObj.R || !sigObj.S) {\n      throw new Error(\"Failed to transform signatures to object: invalid signature \".concat(sig));\n    }\n\n    Object.keys(sigObj).map(k => {\n      sigObj[k] = trimLeadingZero(sigObj[k]);\n    });\n    ret.push(sigObj);\n  }\n\n  return isSingular ? ret[0] : ret;\n};\n/**\n * Returns tx type string.\n * This function uses an old type string.\n *\n * @example\n * const result = caver.utils.getTxTypeStringFromRawTransaction('0x08f83a808505d21dba00824e20945b2840bcbc2be07fb12d9129ed3a02d8e446594401945b2840bcbc2be07fb12d9129ed3a02d8e4465944c4c3018080')\n *\n * @deprecated\n * @ignore\n * @param {string} rawTransaction An RLP-encoded transaction string.\n * @return {string} A transaction type string.\n */\n\n\nconst getTxTypeStringFromRawTransaction = rawTransaction => {\n  if (typeof rawTransaction !== 'string') throw new Error('Invalid raw Tx', rawTransaction);\n  const type = rawTransaction.slice(0, 4);\n  const typeString = txTypeToString[type];\n  return typeString;\n};\n/**\n * Returns tx type string.\n * This function uses an old type string.\n *\n * @example\n * const result = caver.utils.isValidPublicKey('0x3a06fcf2eb4f096e01bc70ab2c81ba79e82af9c62a3ef5fe1fef329c3ad89e8622aed245899ffa530ddd8ebf1a0a66f157b75a38a715f82ad6061af36cbd9cd8')\n *\n * @memberof module:utils\n * @inner\n *\n * @param {string} rawTransaction An RLP-encoded transaction string.\n * @return {string} A transaction type string.\n */\n\n\nconst isValidPublicKey = publicKey => {\n  let pubString = publicKey.replace('0x', '');\n  if (pubString.length === 130 && pubString.slice(0, 2) === '04') pubString = pubString.slice(2);\n  if (pubString.length !== 66 && pubString.length !== 128) return false;\n  if (pubString.length === 66 && !isCompressedPublicKey(pubString)) return false;\n  if (pubString.length === 66) pubString = decompressPublicKey(pubString);\n  const xyPoints = xyPointFromPublicKey(pubString);\n  if (xyPoints === undefined || !xyPoints.length || xyPoints.length !== 2) return false;\n  const point = secp256k1.curve.point(xyPoints[0].slice(2), xyPoints[1].slice(2), true);\n  return secp256k1.keyFromPublic(point).validate().result;\n};\n/**\n * Return `true` is public key is compressed, otherwise `false`.\n *\n * @example\n * const result = caver.utils.isCompressedPublicKey('0x023a06fcf2eb4f096e01bc70ab2c81ba79e82af9c62a3ef5fe1fef329c3ad89e86')\n *\n * @memberof module:utils\n * @inner\n *\n * @param {string} publicKey A public key string.\n * @return {boolean} `true` means compressed.\n */\n\n\nconst isCompressedPublicKey = publicKey => {\n  const compressedIndicators = ['02', '03'];\n  const withoutPrefix = publicKey.replace('0x', '');\n  return withoutPrefix.length === 66 && compressedIndicators.includes(withoutPrefix.slice(0, 2));\n};\n/**\n * Compresses the uncompressed public key.\n *\n * @example\n * const result = caver.utils.compressPublicKey('0x62cef87819b82f62e9c0a38c1fa7dfa089084959df86aca19ff2f6c903db2248b45dc23220ee6bcd8753bb9df8ce7d58e56eabebb14479f3a0ca5ccd4bdea632')\n *\n * @memberof module:utils\n * @inner\n *\n * @param {string} publicKey A public key string.\n * @return {string} A compressed public key.\n */\n\n\nconst compressPublicKey = uncompressedPublicKey => {\n  const isAlreadyCompressed = isCompressedPublicKey(uncompressedPublicKey);\n  if (isAlreadyCompressed) return uncompressedPublicKey;\n  const xyPoints = xyPointFromPublicKey(uncompressedPublicKey);\n\n  if (xyPoints === undefined || !xyPoints.length || xyPoints.length !== 2) {\n    throw new Error('invalid public key');\n  }\n\n  const _xyPoints = _slicedToArray(xyPoints, 2),\n        x = _xyPoints[0],\n        y = _xyPoints[1];\n\n  const keyPair = secp256k1.keyPair({\n    pub: {\n      x: x.replace('0x', ''),\n      y: y.replace('0x', '')\n    },\n    pubEnc: 'hex'\n  });\n  const compressedPublicKey = \"0x\".concat(keyPair.getPublic(true, 'hex'));\n  return compressedPublicKey;\n};\n/**\n * Decompresses the compressed public key.\n *\n * @example\n * const result = caver.utils.decompressPublicKey('0x0262cef87819b82f62e9c0a38c1fa7dfa089084959df86aca19ff2f6c903db2248')\n *\n * @memberof module:utils\n * @inner\n *\n * @param {string} publicKey A public key string.\n * @return {string} A uncompressed public key.\n */\n\n\nconst decompressPublicKey = compressedPublicKey => {\n  if (!isCompressedPublicKey(compressedPublicKey)) {\n    if (!isValidPublicKey(compressedPublicKey)) throw new Error(\"Invalid public key\");\n    return compressedPublicKey;\n  }\n\n  const compressedWithoutPrefix = compressedPublicKey.replace('0x', '');\n  const curve = secp256k1.curve;\n  const decoded = curve.decodePoint(compressedWithoutPrefix, 'hex');\n  const hexEncoded = decoded.encode('hex').slice(2);\n  return \"0x\".concat(hexEncoded);\n};\n\nconst isContractDeployment = txObject => {\n  if (txObject.type) {\n    if (txObject.type.includes('SMART_CONTRACT_DEPLOY') || txObject.type.includes('SmartContractDeploy')) return true;\n    if (txObject.type !== 'LEGACY' && txObject.type !== 'TxTypeLegacyTransaction') return false;\n  }\n\n  if (txObject.data && txObject.data !== '0x' && (!txObject.to || txObject.to === '0x')) return true;\n  return false;\n};\n\nconst isValidRole = role => {\n  switch (role) {\n    case 'roleTransactionKey':\n    case 'roleAccountUpdateKey':\n    case 'roleFeePayerKey':\n    case 'transactionKey':\n    case 'updateKey':\n    case 'feePayerKey':\n      return true;\n  }\n\n  return false;\n}; // ['0x01', '0x', '0x]\n// [['0x01', '0x', '0x]]\n// '0x....'\n// { v: '0x01', r: '0x', s:'0x' }\n// SignatureData { _v: '0x01', _r: '0x', _s:'0x' }\n// [SignatureData { _v: '0x01', _r: '0x', _s:'0x' }]\n\n/**\n * Returns `true` if sig is in the format of empty signature (`SignatureData { _v: '0x01', _r: '0x', _s: '0x' }` or `[SignatureData { _v: '0x01', _r: '0x', _s: '0x' }]`), otherwise it returns `false`.\n *\n * In caver-js, if signatures or feePayerSignatures is empty, the value representing an empty signature, `[SignatureData { _v: '0x01', _r: '0x', _s: '0x' }]`, is returned for the property.\n * This function is used to check whether the given signature is `[SignatureData { _v: '0x01', _r: '0x', _s: '0x' }]` (or `SignatureData { _v: '0x01', _r: '0x', _s: '0x' }` in the 'LEGACY' transaction).\n *\n * @example\n * const result = caver.utils.isEmptySig(['0x01', '0x', '0x'])\n * const result = caver.utils.isEmptySig({ v: '0x01', r: '0x', s: '0x' })\n * const result = caver.utils.isEmptySig({ V: '0x01', R: '0x', S: '0x' })\n * const result = caver.utils.isEmptySig(new caver.wallet.keyring.signatureData(['0x01', '0x', '0x']))\n *\n * const result = caver.utils.isEmptySig([['0x01', '0x', '0x']])\n * const result = caver.utils.isEmptySig([{ v: '0x01', r: '0x', s: '0x' }])\n * const result = caver.utils.isEmptySig([{ V: '0x01', R: '0x', S: '0x' }])\n * const result = caver.utils.isEmptySig([new caver.wallet.keyring.signatureData(['0x01', '0x', '0x'])])\n *\n * @memberof module:utils\n * @inner\n *\n * @param {object|Array.<object>|Array.<string>|Array.<Array.<string>>|SignatureData|Array.<SignatureData>} sig An instance of {@link SignatureData} or array of {@link SignatureData} to check empty or not.\n * @return {boolean} `true` means the sig is empty.\n */\n\n\nconst isEmptySig = sig => {\n  let sigs = sig; // Convert to array format\n\n  if (!_.isArray(sig)) sigs = resolveSignature(sigs); // Format to two-dimentional array\n\n  if (_.isString(sigs[0])) sigs = [sigs];\n\n  for (let s of sigs) {\n    if (!_.isArray(s)) s = resolveSignature(s);\n    if (s.length !== 3) throw new Error(\"Invalid signatures length: \".concat(s.length));\n    if (s[0] !== '0x01' || s[1] !== '0x' || s[2] !== '0x') return false;\n  }\n\n  return true;\n};\n/**\n * Hashes message with Klaytn specific prefix: `keccak256(\"\\x19Klaytn Signed Message:\\n\" + len(message) + message))`\n *\n * @example\n * const result = caver.utils.hashMessage('Hello') // '0x640bfab59b6e27468abd367888f4ab1a1c77aa2b45e76a1d3adcbd039c305917'\n *\n * @memberof module:utils\n * @inner\n *\n * @param {string} data A message to hash. If it is a HEX string, it will be UTF-8 decoded first.\n * @return {string} The hashed message with Klaytn specific prefix.\n */\n\n\nconst hashMessage = data => {\n  const message = isHexStrict(data) ? hexToBytes(data) : data;\n  const messageBuffer = Buffer.from(message);\n  const preamble = \"\\x19Klaytn Signed Message:\\n\".concat(message.length);\n  const preambleBuffer = Buffer.from(preamble); // klayMessage is concatenated buffer (preambleBuffer + messageBuffer)\n\n  const klayMessage = Buffer.concat([preambleBuffer, messageBuffer]); // Finally, run keccak256 on klayMessage.\n\n  return Hash.keccak256(klayMessage);\n};\n/**\n * Recovers the public key that was used to sign the given data.\n *\n * @example\n * const message = 'Some data'\n * const signature = { v: '0x1c', r: '0xd0b8d...', s: '0x5472e...' } // You can get a signature via `keyring.signMessage(...).signatures[0]`.\n * const recoveredPublicKey = caver.utils.recoverPublicKey(message, signature)\n *\n * @memberof module:utils\n * @inner\n *\n * @param {string} message The raw message string. If this message is hased with Klaytn specific prefix, the third parameter should be passed as `true`.\n * @param {SignatureData|Array.<string>|object} signature An instance of `SignatureData`, `[v, r, s]` or `{v, r, s}`.\n * @param {boolean} [isHashed] (optional, default: `false`) If the `isHashed` is true, the given message will NOT automatically be prefixed with \"\\x19Klaytn Signed Message:\\n\" + message.length + message, and be assumed as already prefixed.\n * @return {string}\n */\n\n\nconst recoverPublicKey = (message, signature, isHashed = false) => {\n  if (!isHashed) message = hashMessage(message);\n  if (_.isArray(signature)) signature = {\n    v: signature[0],\n    r: signature[1],\n    s: signature[2]\n  };\n  const vrs = {\n    v: parseInt(signature.v.slice(2), 16),\n    r: signature.r.slice(2),\n    s: signature.s.slice(2)\n  };\n  const ecPublicKey = secp256k1.recoverPubKey(Buffer.from(message.slice(2), 'hex'), vrs, vrs.v < 2 ? vrs.v : 1 - vrs.v % 2);\n  return \"0x\".concat(ecPublicKey.encode('hex', false).slice(2));\n};\n/**\n * Recovers the Klaytn address that was used to sign the given data.\n *\n * @example\n * const message = 'Some data'\n * const signature = { v: '0x1c', r: '0xd0b8d...', s: '0x5472e...' } // You can get a signature via `keyring.signMessage(...).signatures[0]`.\n * const recoveredPublicKey = caver.utils.recover(message, signature)\n *\n * @memberof module:utils\n * @inner\n *\n * @param {string} message The raw message string. If this message is hased with Klaytn specific prefix, the third parameter should be passed as `true`.\n * @param {SignatureData|Array.<string>|object} signature An instance of `SignatureData`, `[v, r, s]` or `{v, r, s}`.\n * @param {boolean} [isHashed] (optional, default: `false`) If the `isHashed` is true, the given message will NOT automatically be prefixed with \"\\x19Klaytn Signed Message:\\n\" + message.length + message, and be assumed as already prefixed.\n * @return {string}\n */\n\n\nconst recover = (message, signature, isHashed = false) => {\n  if (!isHashed) {\n    message = hashMessage(message);\n  }\n\n  return Account.recover(message, Account.encodeSignature(resolveSignature(signature))).toLowerCase();\n};\n/**\n * Returns an address which is derived by a public key.\n * This function simply converts the public key string into address form by hashing it.\n * It has nothing to do with the actual account in the Klaytn.\n *\n * @example\n * const address = caver.utils.publicKeyToAddress('0x{public key}')\n *\n * @memberof module:utils\n * @inner\n *\n * @method publicKeyToAddress\n * @param {string} pubKey The public key string to get the address.\n * @return {string}\n */\n\n\nconst publicKeyToAddress = pubKey => {\n  let publicKey = pubKey.slice(0, 2) === '0x' ? pubKey : \"0x\".concat(pubKey);\n  if (isCompressedPublicKey(publicKey)) publicKey = decompressPublicKey(publicKey); // With '0x' prefix, 65 bytes in uncompressed format.\n\n  if (Buffer.byteLength(publicKey, 'hex') !== 65) throw new Error(\"Invalid public key: \".concat(pubKey));\n  const publicHash = Hash.keccak256(publicKey);\n  const address = \"0x\".concat(publicHash.slice(-40));\n  const addressHash = Hash.keccak256s(address.slice(2));\n  let checksumAddress = '0x';\n\n  for (let i = 0; i < 40; i++) checksumAddress += parseInt(addressHash[i + 2], 16) > 7 ? address[i + 2].toUpperCase() : address[i + 2];\n\n  return checksumAddress;\n};\n\nmodule.exports = {\n  BN: BN,\n  isBN: isBN,\n  BigNumber: BigNumber,\n  isBigNumber: isBigNumber,\n  toBN: toBN,\n  isAddress: isAddress,\n  isBloom: isBloom,\n  // TODO UNDOCUMENTED\n  isTopic: isTopic,\n  // TODO UNDOCUMENTED\n  checkAddressChecksum: checkAddressChecksum,\n  utf8ToHex: utf8ToHex,\n  hexToUtf8: hexToUtf8,\n  hexToNumber: hexToNumber,\n  hexToNumberString: hexToNumberString,\n  numberToHex: numberToHex,\n  toHex: toHex,\n  bufferToHex: bufferToHex,\n  toBuffer: toBuffer,\n  numberToBuffer: numberToBuffer,\n  hexToBytes: hexToBytes,\n  bytesToHex: bytesToHex,\n  isHex: isHex,\n  isHexStrict: isHexStrict,\n  leftPad: leftPad,\n  rightPad: rightPad,\n  toTwosComplement: toTwosComplement,\n  sha3: sha3,\n  parsePredefinedBlockNumber: parsePredefinedBlockNumber,\n  isPredefinedBlockNumber: isPredefinedBlockNumber,\n  isValidBlockNumberCandidate: isValidBlockNumberCandidate,\n  isValidPrivateKey: isValidPrivateKey,\n  isValidNSHSN: isValidNSHSN,\n  parsePrivateKey: parsePrivateKey,\n  parseKlaytnWalletKey: parseKlaytnWalletKey,\n  isKlaytnWalletKey: isKlaytnWalletKey,\n  isContractDeployment: isContractDeployment,\n  rlpEncode: rlpEncode,\n  rlpDecode: rlpDecode,\n  xyPointFromPublicKey: xyPointFromPublicKey,\n  resolveSignature: resolveSignature,\n  transformSignaturesToObject: transformSignaturesToObject,\n  getTxTypeStringFromRawTransaction,\n  trimLeadingZero,\n  makeEven,\n  txTypeToString,\n  isValidPublicKey,\n  isCompressedPublicKey,\n  compressPublicKey,\n  decompressPublicKey,\n  isTxHash,\n  isTxHashStrict,\n  isValidHash,\n  isValidHashStrict,\n  isValidRole: isValidRole,\n  isEmptySig: isEmptySig,\n  hashMessage: hashMessage,\n  recover: recover,\n  recoverPublicKey: recoverPublicKey,\n  publicKeyToAddress: publicKeyToAddress\n};","map":null,"metadata":{},"sourceType":"script"}