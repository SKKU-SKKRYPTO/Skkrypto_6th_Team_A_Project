{"ast":null,"code":"'use strict';\n/* eslint-env browser */\n\nconst _require = require('buffer'),\n      Buffer = _require.Buffer;\n\nconst toAsyncIterable = require('../lib/file-data-to-async-iterable');\n/*\nTransform one of:\n\nBuffer|ArrayBuffer|TypedArray\nBlob|File\n{ path, content: Buffer }\n{ path, content: Blob }\n{ path, content: Iterable<Buffer> }\n{ path, content: AsyncIterable<Buffer> }\n{ path, content: PullStream<Buffer> }\nIterable<Number>\nIterable<{ path, content: Buffer }>\nIterable<{ path, content: Blob }>\nIterable<{ path, content: Iterable<Number> }>\nIterable<{ path, content: AsyncIterable<Buffer> }>\nIterable<{ path, content: PullStream<Buffer> }>\nAsyncIterable<Buffer>\nAsyncIterable<{ path, content: Buffer }>\nAsyncIterable<{ path, content: Blob }>\nAsyncIterable<{ path, content: Iterable<Buffer> }>\nAsyncIterable<{ path, content: AsyncIterable<Buffer> }>\nAsyncIterable<{ path, content: PullStream<Buffer> }>\nPullStream<Buffer>\n\nInto:\n\nAsyncIterable<{ path, content: AsyncIterable<Buffer> }>\n*/\n\n\nmodule.exports = function normalizeInput(input) {\n  // Buffer|ArrayBuffer|TypedArray\n  if (Buffer.isBuffer(input) || ArrayBuffer.isView(input) || input instanceof ArrayBuffer) {\n    return async function* () {\n      // eslint-disable-line require-await\n      yield normalizeTuple({\n        path: '',\n        content: input\n      });\n    }();\n  } // Blob|File\n\n\n  if (typeof Blob !== 'undefined' && input instanceof Blob) {\n    return async function* () {\n      // eslint-disable-line require-await\n      yield normalizeTuple({\n        path: '',\n        content: input\n      });\n    }();\n  } // Iterable<Number>\n  // Iterable<{ path, content: Buffer }>\n  // Iterable<{ path, content: Blob }>\n  // Iterable<{ path, content: Iterable<Number> }>\n  // Iterable<{ path, content: AsyncIterable<Buffer> }>\n  // Iterable<{ path, content: PullStream<Buffer> }>\n\n\n  if (input[Symbol.iterator]) {\n    return async function* () {\n      // eslint-disable-line require-await\n      for (const chunk of input) {\n        if (typeof chunk === 'object' && (chunk.path || chunk.content)) {\n          yield normalizeTuple(chunk);\n        } else {\n          // Must be an Iterable<Number> i.e. Buffer/ArrayBuffer/Array of bytes\n          yield normalizeTuple({\n            path: '',\n            content: input\n          });\n          return;\n        }\n      }\n    }();\n  } // AsyncIterable<Buffer>\n  // AsyncIterable<{ path, content: Buffer }>\n  // AsyncIterable<{ path, content: Blob }>\n  // AsyncIterable<{ path, content: Iterable<Buffer> }>\n  // AsyncIterable<{ path, content: AsyncIterable<Buffer> }>\n  // AsyncIterable<{ path, content: PullStream<Buffer> }>\n\n\n  if (input[Symbol.asyncIterator]) {\n    return async function* () {\n      for await (const chunk of input) {\n        if (typeof chunk === 'object' && (chunk.path || chunk.content)) {\n          yield normalizeTuple(chunk);\n        } else {\n          // Must be an AsyncIterable<Buffer> i.e. a Stream\n          let path = ''; // fs.createReadStream will create a stream with a `path` prop\n          // If available, use it here!\n\n          if (input.path && input.path.split) {\n            path = input.path.split(/[/\\\\]/).pop() || '';\n          }\n\n          yield normalizeTuple({\n            path,\n            content: async function* () {\n              yield chunk;\n\n              for await (const restChunk of input) {\n                yield restChunk;\n              }\n            }()\n          });\n          return;\n        }\n      }\n    }();\n  } // { path, content: Buffer }\n  // { path, content: Blob }\n  // { path, content: Iterable<Buffer> }\n  // { path, content: AsyncIterable<Buffer> }\n  // { path, content: PullStream<Buffer> }\n\n\n  if (typeof input === 'object' && (input.path || input.content)) {\n    // eslint-disable-next-line require-await\n    return async function* () {\n      yield normalizeTuple(input);\n    }();\n  } // PullStream\n\n\n  if (typeof input === 'function') {\n    return async function* () {\n      // eslint-disable-line require-await\n      yield normalizeTuple({\n        path: '',\n        content: input\n      });\n    }();\n  }\n\n  throw new Error('Unexpected input: ' + typeof input);\n};\n\nfunction normalizeTuple({\n  path,\n  content\n}) {\n  return {\n    path: path || '',\n    content: content ? toAsyncIterable(content) : null\n  };\n}","map":null,"metadata":{},"sourceType":"script"}