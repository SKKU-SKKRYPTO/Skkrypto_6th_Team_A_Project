{"ast":null,"code":"/* eslint-disable class-methods-use-this */\n\n/*\n    Copyright 2020 The caver-js Authors\n    This file is part of the caver-js library.\n\n    The caver-js library is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    The caver-js library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with the caver-js. If not, see <http://www.gnu.org/licenses/>.\n*/\nconst lodash = require('lodash');\n\nconst fs = require('fs');\n\nconst IPFSAPI = require('ipfs-http-client-lite');\n\nconst multihash = require('multihashes');\n/**\n * Representing a class for uploading and loading files to IPFS.\n * @hideconstructor\n * @class\n */\n\n\nclass IPFS {\n  /**\n   * Create an IPFS instance.\n   * @param {string} [host] The IPFS Node url to connect with.\n   * @param {number} [port] The port number to use.\n   * @param {boolean} [ssl] With or without SSL. If true, the https protocol is used. Otherwise, the http protocol is used.\n   */\n  constructor(host, port, ssl) {\n    if (host !== undefined && port !== undefined && ssl !== undefined) {\n      this.setIPFSNode(host, port, ssl);\n    }\n  }\n  /**\n   * Initializes a connection with an IPFS Node.\n   * When an IPFS Node information is set through this function, you can upload files to IPFS or load files from IPFS.\n   *\n   * @example\n   * caver.ipfs.setIPFSNode('localhost', 5001, false)\n   *\n   * @param {string} host The IPFS Node url to connect with.\n   * @param {number} port The port number to use.\n   * @param {boolean} ssl With or without SSL. If true, the https protocol is used. Otherwise, the http protocol is used.\n   * @return {void}\n   */\n\n\n  setIPFSNode(host, port, ssl) {\n    const protocol = ssl ? 'https' : 'http';\n    this.ipfs = IPFSAPI({\n      apiUrl: \"\".concat(protocol, \"://\").concat(host, \":\").concat(port)\n    });\n  }\n  /**\n   * Adds a file to IPFS. The {@link https://docs.ipfs.io/concepts/content-addressing/#content-addressing-and-cids|CID(Content Identifier)} of the uploaded file is returned.\n   * If the path of a file is passed, the contents of the file are loaded from the path and uploaded to IPFS. If a buffer is passed, it is uploaded to IPFS directly.\n   *\n   * If the `data` parameter is a `Buffer` or `ArrayBuffer`, upload to IPFS directly without using `fs`.\n   * If the `data` parameter is a string, use `fs` to read the file.\n   * Since `fs` is a module that can only be used on the server side, if it is client-side code,\n   * it must read the file in advance and pass the file contents in the format of `ArrayBuffer`.\n   *\n   * If you get a \"Error: Can't resolve 'fs'\" error when building your client code, add the following to your \"webpack.config.json\" file.\n   * ```\n   * module.exports = {\n   *     ...\n   *     node: {\n   *         fs: 'empty',\n   *     },\n   *     ...\n   * }\n   * ```\n   *\n   * If you use Next.js web framework(https://nextjs.org/), add the following to your \"next.config.json\" file.\n   * ```\n   * module.exports = {\n   *     ...\n   *     webpack: (config, { isServer }) => {\n   *         // Fixes npm packages that depend on `fs` module\n   *         if (!isServer) {\n   *             config.node = {\n   *                 fs: 'empty'\n   *             }\n   *         }\n   *         return config\n   *     },\n   *     ...\n   * }\n   * ```\n   *\n   * @example\n   * const cid = await caver.ipfs.add('./test.txt')\n   * const cid = await caver.ipfs.add(Buffer.from('test data'))\n   *\n   * @param {string|Buffer|ArrayBuffer} data The file path string or file contents.\n   * @return {Promise<string>}\n   */\n\n\n  async add(data) {\n    if (!this.ipfs) throw new Error(\"Please set IPFS Node through 'caver.ipfs.setIPFSNode'.\"); // Read file\n\n    if (lodash.isString(data)) {\n      if (typeof window !== 'undefined') throw new Error(\"Cannot use fs module: Please pass the file contents as a parameter of type Buffer or ArrayBuffer.\");\n      data = fs.readFileSync(data);\n    }\n\n    if (!lodash.isBuffer(data) && !lodash.isArrayBuffer(data)) throw new Error(\"Invalid data: \".concat(data));\n    const ret = await this.ipfs.add(Buffer.from(data));\n    return ret[0].hash;\n  }\n  /**\n   * Returns a file addressed by a valid IPFS path.\n   *\n   * @example\n   * const fileContents = await caver.ipfs.get('Qmd9thymMS6mejhEDZfwXPowSDunzgma9ex4ezpCSRZGwC')\n   *\n   * @param {string} hash An {@link https://docs.ipfs.io/concepts/content-addressing/#content-addressing-and-cids|CID(Content Identifier)} of the file to download.\n   * @return {Promise<Buffer>}\n   */\n\n\n  async get(hash) {\n    if (!this.ipfs) throw new Error(\"Please set IPFS Node through 'caver.ipfs.setIPFSNode'.\");\n    const ret = await this.ipfs.cat(hash);\n    return ret;\n  }\n  /**\n   * Converts a {@link https://docs.ipfs.io/concepts/content-addressing/#content-addressing-and-cids|CID(Content Identifier)} to a {@link https://multiformats.io/multihash/|Multihash}.\n   *\n   * @example\n   * // This will return '0x1220dc1dbe0bcf1e5f6cce80bd3d7e7d873801c5a1732add889c0f25391d53470dc3'\n   * const multihash = caver.ipfs.toHex('Qmd9thymMS6mejhEDZfwXPowSDunzgma9ex4ezpCSRZGwC')\n   *\n   * @param {string} hash A {@link https://docs.ipfs.io/concepts/content-addressing/#content-addressing-and-cids|CID(Content Identifier)} to convert.\n   * @return {string}\n   */\n\n\n  toHex(hash) {\n    const buf = multihash.fromB58String(hash);\n    return \"0x\".concat(multihash.toHexString(buf));\n  }\n  /**\n   * Converts to {@link https://docs.ipfs.io/concepts/content-addressing/#content-addressing-and-cids|CID(Content Identifier)} from a {@link https://multiformats.io/multihash/|Multihash}.\n   *\n   * @example\n   * // This will return 'Qmd9thymMS6mejhEDZfwXPowSDunzgma9ex4ezpCSRZGwC'\n   * const multihash = caver.ipfs.fromHex('0x1220dc1dbe0bcf1e5f6cce80bd3d7e7d873801c5a1732add889c0f25391d53470dc3')\n   *\n   * @param {string} hash A {@link https://multiformats.io/multihash/|Multihash} to convert.\n   * @return {string}\n   */\n\n\n  fromHex(contentHash) {\n    const hex = contentHash.substring(2);\n    const buf = multihash.fromHexString(hex);\n    return multihash.toB58String(buf);\n  }\n\n}\n\nmodule.exports = IPFS;","map":null,"metadata":{},"sourceType":"script"}