{"ast":null,"code":"/*\n    Copyright 2020 The caver-js Authors\n    This file is part of the caver-js library.\n\n    The caver-js library is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    The caver-js library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with the caver-js. If not, see <http://www.gnu.org/licenses/>.\n*/\nconst _ = require('lodash');\n\nconst RLP = require('eth-lib/lib/rlp');\n\nconst AccountKeyWeightedMultiSig = require('./accountKeyWeightedMultiSig');\n\nconst AccountKeyLegacy = require('./accountKeyLegacy');\n\nconst AccountKeyPublic = require('./accountKeyPublic');\n\nconst AccountKeyFail = require('./accountKeyFail');\n\nconst utils = require('../../../caver-utils');\n\nconst _require = require('./accountKeyHelper'),\n      ACCOUNT_KEY_TAG = _require.ACCOUNT_KEY_TAG;\n\nconst _require2 = require('../../../caver-wallet/src/keyring/keyringHelper'),\n      KEY_ROLE = _require2.KEY_ROLE;\n\nconst WeightedMultiSigOptions = require('./weightedMultiSigOptions');\n\nfunction isValidRoleBasedKeyFormat(roleBasedAccountKeys) {\n  if (!_.isArray(roleBasedAccountKeys)) return false;\n  if (roleBasedAccountKeys.length > KEY_ROLE.roleLast) return false;\n\n  for (const accountKey of roleBasedAccountKeys) {\n    if (accountKey !== undefined && !(accountKey instanceof AccountKeyLegacy) && !(accountKey instanceof AccountKeyPublic) && !(accountKey instanceof AccountKeyFail) && !(accountKey instanceof AccountKeyWeightedMultiSig)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n/**\n * Representing an AccountKeyRoleBased.\n * @class\n * @hideconstructor\n */\n\n\nclass AccountKeyRoleBased {\n  /**\n   * Decodes an RLP-encoded AccountKeyRoleBased string.\n   *\n   * @example\n   * const accountKey = caver.account.accountKey.accountKeyRoleBased.decode('0x{encoded account key}')\n   *\n   * @param {string} rlpEncodedKey - An RLP-encoded AccountKeyRoleBased string.\n   * @return {AccountKeyRoleBased}\n   */\n  static decode(rlpEncodedKey) {\n    rlpEncodedKey = utils.addHexPrefix(rlpEncodedKey);\n    if (!rlpEncodedKey.startsWith(ACCOUNT_KEY_TAG.ACCOUNT_KEY_ROLE_BASED_TAG)) throw new Error(\"Cannot decode to AccountKeyRoleBased. The prefix must be \".concat(ACCOUNT_KEY_TAG.ACCOUNT_KEY_ROLE_BASED_TAG, \": \").concat(rlpEncodedKey));\n    const keys = RLP.decode(\"0x\".concat(rlpEncodedKey.slice(ACCOUNT_KEY_TAG.ACCOUNT_KEY_ROLE_BASED_TAG.length)));\n    const accountKeys = [];\n\n    for (const key of keys) {\n      if (key.startsWith(ACCOUNT_KEY_TAG.ACCOUNT_KEY_ROLE_BASED_TAG)) throw new Error('Nested role based key.');\n\n      if (key.startsWith(ACCOUNT_KEY_TAG.ACCOUNT_KEY_NIL_TAG)) {\n        accountKeys.push(undefined);\n      } else if (key.startsWith(ACCOUNT_KEY_TAG.ACCOUNT_KEY_LEGACY_TAG)) {\n        accountKeys.push(AccountKeyLegacy.decode(key));\n      } else if (key.startsWith(ACCOUNT_KEY_TAG.ACCOUNT_KEY_PUBLIC_TAG)) {\n        accountKeys.push(AccountKeyPublic.decode(key));\n      } else if (key.startsWith(ACCOUNT_KEY_TAG.ACCOUNT_KEY_FAIL_TAG)) {\n        accountKeys.push(AccountKeyFail.decode(key));\n      } else if (key.startsWith(ACCOUNT_KEY_TAG.ACCOUNT_KEY_WEIGHTED_MULTISIG_TAG)) {\n        accountKeys.push(AccountKeyWeightedMultiSig.decode(key));\n      } else {\n        throw new Error(\"Failed to decode RLP-encoded account key. Invalid RLP-encoded account key \".concat(key));\n      }\n    }\n\n    return new AccountKeyRoleBased(accountKeys);\n  }\n  /**\n   * Creates an instance of AccountKeyRoleBased.\n   *\n   * @example\n   * const publicKeyArray = [\n   *      [ '0x{public key1}', '0x{public key2}' ], // roleTransactionKey\n   *      [ '0x{public key3}', '0x{public key4}', '0x{public key5}' ], // roleAccountUpdateKey\n   *      [ '0x{public key6}', '0x{public key7}', '0x{public key8}', '0x{public key9}' ], // roleFeePayerKey\n   * ]\n   * // For option object, you can use `new caver.account.weightedMultiSigOptions(2, [1, 1])`\n   * // instead of `{ threshold: 2, weights: [1, 1] }`.\n   * const options = [\n   *      { threshold: 2, weights: [1, 1] },\n   *      { threshold: 2, weights: [1, 1, 2] },\n   *      { threshold: 3, weights: [1, 1, 2, 2] }\n   * ]\n   * const accountKey = caver.account.accountKey.accountKeyRoleBased.fromRoleBasedPublicKeysAndOptions(publicKeyArray, options)\n   *\n   * // Update only roleTransactionKey and roleFeePayerKey\n   * const publicKeyArrayToUpdatePartial = [\n   *      [ '0x{public key1}', '0x{public key2}' ], // roleTransactionKey\n   *      [], // roleAccountUpdateKey -> If not defined the key(s) to use in the specific role, this role key is not updated.\n   *      [ '0x{public key3}', '0x{public key4}' ], // roleFeePayerKey\n   * ]\n   * const options = [\n   *      { threshold: 2, weights: [1, 1] },\n   *      {},\n   *      { threshold: 3, weights: [1, 2] }\n   * ]\n   * const accountKey = caver.account.accountKey.accountKeyRoleBased.fromRoleBasedPublicKeysAndOptions(publicKeyArrayToUpdatePartial, options)\n   *\n   * // Update to AccountKeyLegacy or AccountKeyFail\n   * const publicKeyArrayWithLegacyAndFail = [\n   *      [ '0x{public key1}', '0x{public key2}' ], // roleTransactionKey\n   *      [ new caver.account.accountKey.accountKeyLegacy() ], // roleAccountUpdateKey will use AccountKeyLegacy when update an account key of the Klaytn account.\n   *      [ new caver.account.accountKey.accountKeyFail() ], // roleFeePayerKey will be updated to AccountKeyFail, so this Klaytn account cannot pay a fee as a fee payer.\n   * ]\n   * const options = [\n   *      { threshold: 2, weights: [1, 1] },\n   *      {},\n   *      {}\n   * ]\n   * const accountKey = caver.account.accountKey.accountKeyRoleBased.fromRoleBasedPublicKeysAndOptions(publicKeyArrayWithLegacyAndFail, options)\n   *\n   * @param {Array.<AccountKeyLegacy|AccountKeyFail|Array.<string>>} roleBasedPubArray - An array of public key strings.\n   * @param {Array.<WeightedMultiSigOptions|object>} options - An array of options which defines threshold and weight.\n   * @return {AccountKeyRoleBased}\n   */\n\n\n  static fromRoleBasedPublicKeysAndOptions(roleBasedPubArray, options) {\n    if (!options) options = Array(KEY_ROLE.roleLast).fill(new WeightedMultiSigOptions());\n    const accountKeys = []; // Format will be like below\n    // keyArray = [[pub, pub], [pub], [pub, pub, pub]]\n    // keyArray = [[accountKeyLegacy], [accountKeyFail], [pub, pub, pub]]\n    // keyArray = [['legacy'], ['fail'], []]\n    // options = [{threshold: 1, weights: [1,1]}, {}, {threshold: 1, weights: [1,1,1]}]\n\n    for (let i = 0; i < roleBasedPubArray.length; i++) {\n      if (!(options[i] instanceof WeightedMultiSigOptions)) options[i] = WeightedMultiSigOptions.fromObject(options[i]); // To handle instance of AccountKeyLegacy or AccountKeyFail\n\n      if (!_.isArray(roleBasedPubArray[i])) {\n        throw new Error(\"Invalid format of keys: Each role should define the key to use in an array form.\");\n      } // Empty key array means AccountKeyNil\n\n\n      if (roleBasedPubArray[i].length === 0) {\n        if (!options[i].isEmpty()) throw new Error(\"Invalid options: AccountKeyNil cannot have options.\");\n        accountKeys.push(undefined);\n        continue;\n      }\n\n      if (roleBasedPubArray[i].length === 1) {\n        if (roleBasedPubArray[i][0] instanceof AccountKeyLegacy || roleBasedPubArray[i][0] instanceof AccountKeyFail || roleBasedPubArray[i][0] === 'legacy' || roleBasedPubArray[i][0] === 'fail') {\n          if (!options[i].isEmpty()) throw new Error(\"Invalid options: AccountKeyLegacy or AccountKeyFail cannot have options.\");\n          if (roleBasedPubArray[i][0] === 'legacy') roleBasedPubArray[i][0] = new AccountKeyLegacy();\n          if (roleBasedPubArray[i][0] === 'fail') roleBasedPubArray[i][0] = new AccountKeyFail();\n          accountKeys.push(roleBasedPubArray[i][0]);\n          continue;\n        }\n\n        if (options[i].isEmpty()) {\n          accountKeys.push(AccountKeyPublic.fromPublicKey(roleBasedPubArray[i][0]));\n          continue;\n        }\n      }\n\n      accountKeys.push(AccountKeyWeightedMultiSig.fromPublicKeysAndOptions(roleBasedPubArray[i], options[i]));\n    }\n\n    return new AccountKeyRoleBased(accountKeys);\n  }\n  /**\n   * Create an instance of AccountKeyRoleBased.\n   * @param {Array.<AccountKeyLegacy|AccountKeyPublic|AccountKeyFail|AccountKeyWeightedMultiSig>} accountKeyArray - An array containing arrays of instances of AccountKeyPublic or AccountKeyWeightedMultiSig for each role.\n   */\n\n\n  constructor(accountKeyArray) {\n    this.accountKeys = accountKeyArray;\n  }\n  /**\n   * @type {Array.<AccountKeyLegacy|AccountKeyPublic|AccountKeyFail|AccountKeyWeightedMultiSig>}\n   */\n\n\n  get accountKeys() {\n    return this._accountKeys;\n  }\n\n  set accountKeys(keys) {\n    if (!isValidRoleBasedKeyFormat(keys)) throw new Error(\"Invalid role-based account key format.\");\n    this._accountKeys = keys;\n  }\n  /**\n   * Returns an RLP-encoded AccountKeyRoleBased string.\n   *\n   * @example\n   * const encoding = accountKeyRoleBased.getRLPEncoding()\n   *\n   * @return {string}\n   */\n\n\n  getRLPEncoding() {\n    const encodedAccountKeys = [];\n\n    for (const accountKey of this.accountKeys) {\n      if (accountKey === undefined) {\n        encodedAccountKeys.push(ACCOUNT_KEY_TAG.ACCOUNT_KEY_NIL_TAG);\n        continue;\n      }\n\n      encodedAccountKeys.push(accountKey.getRLPEncoding());\n    }\n\n    return ACCOUNT_KEY_TAG.ACCOUNT_KEY_ROLE_BASED_TAG + RLP.encode(encodedAccountKeys).slice(2);\n  }\n\n}\n\nmodule.exports = AccountKeyRoleBased;","map":null,"metadata":{},"sourceType":"script"}