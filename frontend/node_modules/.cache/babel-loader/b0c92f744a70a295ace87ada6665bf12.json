{"ast":null,"code":"/*\n    Copyright 2020 The caver-js Authors\n    This file is part of the caver-js library.\n\n    The caver-js library is free software: you can redistribute it and/or modify\n    it under the terms of the GNU Lesser General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    The caver-js library is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License\n    along with the caver-js. If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/* eslint-disable no-unused-vars */\n\n/* eslint-disable class-methods-use-this */\nconst _ = require('lodash');\n\nconst utils = require('../../../caver-utils');\n\nconst PrivateKey = require('./privateKey');\n\nconst _require = require('./keyringHelper'),\n      KEY_ROLE = _require.KEY_ROLE,\n      MAXIMUM_KEY_NUM = _require.MAXIMUM_KEY_NUM,\n      isMultipleKeysFormat = _require.isMultipleKeysFormat,\n      isRoleBasedKeysFormat = _require.isRoleBasedKeysFormat;\n\nconst Account = require('../../../caver-account');\n\nconst _require2 = require('../../../caver-account/src/accountKey/accountKeyHelper'),\n      fillWeightedMultiSigOptionsForRoleBased = _require2.fillWeightedMultiSigOptionsForRoleBased;\n\nconst _require3 = require('./keyringHelper'),\n      validateForSigning = _require3.validateForSigning,\n      validateIndexWithKeys = _require3.validateIndexWithKeys,\n      encryptKey = _require3.encryptKey,\n      formatEncrypted = _require3.formatEncrypted;\n/**\n * `RoleBasedKeyring` is a class that stores the address of the account and the private keys to be used for each role in the form of an array.\n *\n * `RoleBasedKeyring` defines keys which is implemented as a two-dimensional array (empty keys looks like `[ [], [], [] ]`) that can include multiple keys for each role.\n * The first array element defines the private key(s) for `roleTransactionKey`, the second defines private key(s) for `roleAccountUpdateKey`, and the third defines the private key(s) for `roleFeePayerKey`.\n *\n * @class\n * @hideconstructor\n */\n\n\nclass RoleBasedKeyring {\n  /**\n   * creates a RoleBasedKeyring.\n   * @param {string} address - The address of keyring.\n   * @param {Array.<Array<string>>|Array.<Array<PrivateKey>>} keys - The keys to use in RoleBasedKeyring.\n   */\n  constructor(address, keys) {\n    this.address = address;\n    this.keys = keys;\n  }\n  /**\n   * @type {string}\n   */\n\n\n  get address() {\n    return this._address;\n  }\n\n  set address(addressInput) {\n    if (!utils.isAddress(addressInput)) throw new Error(\"Invalid address : \".concat(addressInput));\n    this._address = utils.addHexPrefix(addressInput).toLowerCase();\n  }\n  /**\n   * @type {Array.<Array.<PrivateKey>>}\n   */\n\n\n  get keys() {\n    return this._keys;\n  }\n\n  set keys(keyInput) {\n    if (keyInput === null) {\n      this._key = null;\n      return;\n    }\n\n    this._keys = formattingForKeyInKeyring(keyInput);\n  }\n  /**\n   * @type {Array.<PrivateKey>}\n   */\n\n\n  get roleTransactionKey() {\n    return this.getKeyByRole(KEY_ROLE.roleTransactionKey);\n  }\n  /**\n   * @type {Array.<PrivateKey>}\n   */\n\n\n  get roleAccountUpdateKey() {\n    return this.getKeyByRole(KEY_ROLE.roleAccountUpdateKey);\n  }\n  /**\n   * @type {Array.<PrivateKey>}\n   */\n\n\n  get roleFeePayerKey() {\n    return this.getKeyByRole(KEY_ROLE.roleFeePayerKey);\n  }\n  /**\n   * Returns public key strings for each roles.\n   *\n   * @example\n   * const publicKeys = keyring.getPublicKey()\n   *\n   * @param {boolean} [compressed] Whether in compressed format or not.\n   * @return {Array.<Array<string>>} The public keys of the keyring.\n   */\n\n\n  getPublicKey(compressed = false) {\n    const publicKeys = generateKeysFormat();\n\n    for (let i = 0; i < KEY_ROLE.roleLast; i++) {\n      for (const k of this._keys[i]) {\n        publicKeys[i].push(k.getPublicKey(compressed));\n      }\n    }\n\n    return publicKeys;\n  }\n  /**\n   * Returns a copied RoleBasedKeyring instance.\n   *\n   * @example\n   * const copied = keyring.copy()\n   *\n   * @return {RoleBasedKeyring} A copied RoleBasedKeyring instance.\n   */\n\n\n  copy() {\n    return new RoleBasedKeyring(this.address, this.keys);\n  }\n  /**\n   * Signs with transactionHash with the private keys and returns signatures.\n   *\n   * If you want to define an `index` when using RoleBasedKeyring, the `index` must be less than the length of the specific role key.\n   * And `RoleBasedKeyring` has the private key(s) defined by {@link KeyringFactory.role|caver.wallet.keyring.role}, so signs using the key(s) defined in the role.\n   *\n   * If the user has not defined an `index` parameter, `keyring.sign` signs transaction using all the private keys used by the role.\n   * If `index` is defined, the `keyring.sign` signs transaction using only one private key at the index.\n   * The role used in caver-js can be checked through {@link KeyringFactory.role|caver.wallet.keyring.role}.\n   *\n   * @param {string} transactionHash The hash of transaction.\n   * @param {string|number} chainId The chainId specific to the network.\n   * @param {number} role A number indicating the role of the key. You can use `caver.wallet.keyring.role`.\n   * @param {number} [index] The index of the key to be used. If index is undefined, all private keys in keyring will be used.\n   * @return {SignatureData|Array.<SignatureData>} A {@link SignatureData} when `index` is deinfed, otherwise an array of {@link SignatureData}.\n   */\n\n\n  sign(transactionHash, chainId, role, index) {\n    validateForSigning(transactionHash, chainId);\n    const keys = this.getKeyByRole(role);\n\n    if (index !== undefined) {\n      validateIndexWithKeys(index, keys.length);\n      return keys[index].sign(transactionHash, chainId);\n    }\n\n    const signatures = [];\n\n    for (const k of keys) {\n      signatures.push(k.sign(transactionHash, chainId));\n    }\n\n    return signatures;\n  }\n  /**\n   * Signs message with Klaytn-specific prefix.\n   *\n   * This calculates a Klaytn-specific signature with:\n   * `sign(keccak256(\"\\x19Klaytn Signed Message:\\n\" + len(message) + message)))`.\n   *\n   * If you want to define an `index` when using RoleBasedKeyring, the `index` must be less than the length of the specific role key.\n   * And `RoleBasedKeyring` has the private key(s) defined by {@link KeyringFactory.role|caver.wallet.keyring.role}, so signs using the key(s) defined in the role.\n   *\n   * If the user has not provided the `index` parameter, `caver.wallet.signMessage` signs message using all the private keys used by the role.\n   * If the `index` parameter is given, `caver.wallet.signMessage` signs message using only one private key at the given index.\n   * The role used in caver-js can be found from {@link KeyringFactory.role|caver.wallet.keyring.role}.\n   *\n   * @example\n   * const signed = keyring.signMessage('message to sign', caver.wallet.keyring.role.roleTransactionKey)\n   *\n   * @param {string} message The message string to sign.\n   * @param {number} role A number indicating the role of the key. You can use {@link KeyringFactory.role|caver.wallet.keyring.role}.\n   * @param {number} [index] The index of the key to be used.\n   * @return {KeyringContainer.SignedMessage} An object that includes the result of signing.\n   */\n\n\n  signMessage(message, role, index) {\n    if (role === undefined) throw new Error(\"role should be defined for signMessage. Please use 'caver.wallet.keyring.role'.\");\n    const messageHash = utils.hashMessage(message);\n    const keys = this.getKeyByRole(role);\n    const signatures = [];\n\n    if (index !== undefined) {\n      validateIndexWithKeys(index, keys.length);\n      signatures.push(keys[index].signMessage(messageHash));\n    } else {\n      for (const k of keys) {\n        signatures.push(k.signMessage(messageHash));\n      }\n    }\n\n    return {\n      messageHash,\n      signatures,\n      message\n    };\n  }\n  /**\n   * Returns the private key(s) used by the role entered as a parameter.\n   *\n   * @example\n   * const key = keyring.getKeyByRole(caver.wallet.keyring.role.roleTransactionKey)\n   *\n   * @param {number} role A number indicating the role of the key. You can use {@link KeyringFactory.role|caver.wallet.keyring.role}.\n   * @return {Array.<PrivateKey>} An instance of PrivateKey.\n   */\n\n\n  getKeyByRole(role) {\n    if (role === undefined) throw new Error(\"role should be defined.\");\n    if (role >= KEY_ROLE.roleLast || role < 0) throw new Error(\"Invalid role number: \".concat(role));\n    let key = this._keys[role];\n\n    if (key.length === 0 && role > KEY_ROLE.roleTransactionKey) {\n      if (this._keys[KEY_ROLE.roleTransactionKey].length === 0) {\n        throw new Error(\"The key with \".concat(KEY_ROLE[role], \" role does not exist. The \").concat(KEY_ROLE[0], \" for the default role is also empty.\"));\n      }\n\n      key = this._keys[KEY_ROLE.roleTransactionKey];\n    }\n\n    return key;\n  }\n  /**\n   * Returns the {@link Account} instance for updating the {@link Account.AccountKey|AccountKey} of the Klaytn accounts.\n   * The {@link Account} instance has an {@link Account.AccountKey|AccountKey} instance that can contain public key(s) inside, which will be sent to Klaytn Network and used for validating transactions.\n   * Please note that if you update the AccountKey of the Account stored in the Klaytn, the old private key(s) cannot be used anymore.\n   *\n   * `RoleBasedKeyring` returns an {@link Account} instance that includes the address in the keyring and an instance of {@link AccountKeyRoleBased}.\n   *\n   * @example\n   * const account = keyring.toAccount()\n   *\n   * @param {Array.<WeightedMultiSigOptions>} [options] An array of the `WeightedMultiSigOptions` instances containing information that should be defined when updating your existing account to the one with a number of private keys. The `RoleBasedKeyring` uses different private keys for each role, a `WeightedMultiSigOptions` instance must be defined for each role in an array. If multiple keys are used and `options` are not defined for specific role, defualt WeightedMultiSigOptions (`{ threshold: 1, weights: [1, 1...}}`) is used.\n   * @return {Account} An Account instance to be used when a user updates AccountKey for their account in the Klaytn. Note that if you want to replace the existing keyring (or the existing private key) with a new keyring (or a new private key) for your account, you must update your AccountKey by sending an Account Update transaction to Klaytn beforehand.\n   */\n\n\n  toAccount(options) {\n    if (options !== undefined && !_.isArray(options)) throw new Error(\"options for an account should define threshold and weight for each roles in an array format\");\n    const lengths = [];\n\n    for (const k of this.keys) lengths.push(k.length);\n\n    options = fillWeightedMultiSigOptionsForRoleBased(lengths, options);\n    const publicKeysByRole = this.getPublicKey();\n    return Account.createWithAccountKeyRoleBased(this.address, publicKeysByRole, options);\n  }\n  /**\n   * Encrypts a keyring and returns a keystore v4 standard.\n   * For more information, please refer to {@link https://kips.klaytn.com/KIPs/kip-3|KIP-3}.\n   *\n   * `options` can include below:\n   * {\n   *   salt: ...,\n   *   iv: ...,\n   *   kdf: ...,\n   *   dklen: ...,\n   *   c: ...,\n   *   n: ...,\n   *   r: ...,\n   *   p: ...,\n   *   cipher: ...,\n   *   uuid: ...,\n   *   cipher: ...,\n   * }\n   *\n   * @example\n   * const encrypted = keyring.encrypt('password')\n   *\n   * @param {string} password The password to be used for encryption. The encrypted key store can be decrypted with this password.\n   * @param {object} [options] The options parameter allows you to specify the values to use when using encrypt.\n   * @return {KeyringFactory.Keystore} The encrypted keystore v4.\n   */\n\n\n  encrypt(password, options = {}) {\n    const keyring = [];\n\n    for (let i = KEY_ROLE.roleTransactionKey; i < KEY_ROLE.roleLast; i++) {\n      const roledKey = this._keys[i];\n      keyring.push(encryptKey(roledKey, password, options));\n    }\n\n    return formatEncrypted(4, this._address, keyring, options);\n  }\n  /**\n   * Returns the {@link https://docs.klaytn.com/klaytn/design/accounts#klaytn-wallet-key-format|KlaytnWalletKey} string for the keyring.\n   * This function will throw error because `MultipleKeyring` uses more than one private key.\n   *\n   * @example\n   * const klaytnWalletKey = keyring.getKlaytnWalletKey()\n   *\n   * @ignore\n   * @return {string}\n   */\n\n\n  getKlaytnWalletKey() {\n    throw new Error(\"Not supported for this class.\");\n  }\n  /**\n   * Encrypts a keyring and returns a keystore v3 object.\n   *\n   * Note that {@link MultipleKeyring} and {@link RoleBasedKeyring} cannot use encryptV3.\n   * In this case, please use {@link MultipleKeyring#encrypt|keyring.encrypt} with a keystore V4 standard.\n   *\n   * @example\n   * const encrypted = keyring.encryptV3('password')\n   *\n   * @ignore\n   * @param {string} password The password to be used for keyring encryption. The encrypted key store can be decrypted with this password.\n   * @param {object} [options] The options to use when encrypt a keyring. See `keyring.encrypt` for more detail about options.\n   * @return {object}\n   */\n\n\n  encryptV3(password, options) {\n    throw new Error(\"Not supported for this class. Use 'keyring.encrypt(password)'.\");\n  }\n  /**\n   * Returns `true` if keyring has decoupled key.\n   *\n   * @example\n   * const isDecupled = keyring.isDecoupled()\n   *\n   * @return {boolean} `true` if keyring has decoupled key.\n   */\n\n\n  isDecoupled() {\n    return true;\n  }\n\n}\n\nmodule.exports = RoleBasedKeyring;\n/**\n * Format the key parameters passed by the user to create a keyring instance into a two-dimensional array containing PrivateKey instances.\n *\n * The cases of the parameter that the user passes to the function is as follows, and this function formats it as a two-dimensional array.\n * PrivateKey instance: PrivateKey{}\n * single private key string: `0x{private key}`\n * multiple private key strings: [`0x{private key}`, `0x{private key}`]\n * multiple PrivateKey instances: [PrivateKey{}, PrivateKey{}]\n * role-based private key strings: [[`0x{private key}`], [`0x{private key}`, `0x{private key}`], [`0x{private key}`]]\n * role-based PrivateKey instances: [[PrivateKey{}], [PrivateKey{}, PrivateKey{}], [PrivateKey{}]]\n *\n * @param {string|PrivateKey|Array.<string|PrivateKey>|Array.<Array.<string|PrivateKey>>} keyInput The input parameter for key variable in Keyring.\n * @return {Array.<Array.<PrivateKey>>}\n */\n\nfunction formattingForKeyInKeyring(keyInput) {\n  if (keyInput === null) {\n    return keyInput;\n  }\n\n  if (keyInput instanceof PrivateKey || _.isString(keyInput)) {\n    keyInput = [[keyInput], [], []];\n  } else if (isMultipleKeysFormat(keyInput)) {\n    // [`0x{private key}`, `0x{private key}`, `0x{private key}`]\n    keyInput = [keyInput, [], []];\n  } else if (!isRoleBasedKeysFormat(keyInput)) {\n    throw new Error(\"Invalid format for key variable in keyring\");\n  }\n\n  const keys = generateKeysFormat();\n\n  for (let i = 0; i < KEY_ROLE.roleLast; i++) {\n    fillRoleKey(keys, i, keyInput[i]);\n  }\n\n  return keys;\n}\n\nfunction generateKeysFormat() {\n  return Array(KEY_ROLE.roleLast).fill(null).map(() => []);\n}\n\nfunction fillRoleKey(keys, role, keyToAdd) {\n  if (keyToAdd === undefined) return;\n  keyToAdd = Array.isArray(keyToAdd) ? keyToAdd : [keyToAdd];\n  if (keyToAdd.length > MAXIMUM_KEY_NUM) throw new Error(\"The maximum number of private keys that can be used in keyring is \".concat(MAXIMUM_KEY_NUM, \".\"));\n  if (role >= KEY_ROLE.roleLast) throw new Error(\"Unsupported role number. The role number should be less than \".concat(KEY_ROLE.roleLast, \". Please use 'caver.wallet.keyring.role'\"));\n\n  for (const keyString of keyToAdd) {\n    const key = keyString instanceof PrivateKey ? keyString : new PrivateKey(keyString);\n    keys[role].push(key);\n  }\n}","map":null,"metadata":{},"sourceType":"script"}